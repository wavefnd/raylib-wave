

// ----------------------------------------

struct AudioCallback {
    ptr: ptr<void>;
}

fun GetMouseRay(position: Vector2, camera: Camera) -> Ray {
    return GetScreenToWorldRay(position, camera);
}

extern(c) {
    fun InitWindow(width: i32, height: i32, title: ptr<u8>);
    fun CloseWindow();
    fun WindowShouldClose();
    fun IsWindowReady();
    fun IsWindowReady();
    fun IsWindowFullscreen();
    fun IsWindowHidden();
    fun IsWindowMinimized();
    fun IsWindowMaximized();
    fun IsWindowFocused();
    fun IsWindowResized();
    fun IsWindowState(flag: u32);
    fun SetWindowState(flags: u32);
    fun ClearWindowState(flags: u32);
    fun ToggleFullscreen();
    fun ToggleBorderlessWindowed();
    fun MaximizeWindow();
    fun MinimizeWindow();
    fun RestoreWindow();
    fun SetWindowIcon(image: Image);
    fun SetWindowIcons(images: ptr<Image>, count: i32);
    fun SetWindowTitle(title: ptr<i8>);
    fun SetWindowPosition(x: i32, y: i32);
    fun SetWindowMonitor(monitor: i32);
    fun SetWindowMinSize(width: i32, height: i32);
    fun SetWindowMaxSize(width: i32, height: i32);
    fun SetWindowSize(width: i32, height: i32);
    fun SetWindowOpacity(opacity: f32);
    fun SetWindowFocused();
    fun GetWindowHandle() -> ptr<void>;
    fun GetScreenWidth();
    fun GetScreenHeight();
    fun GetRenderWidth();
    fun GetRenderHeight();
    fun GetMonitorCount();
    fun GetCurrentMonitor();
    fun GetMonitorPosition(monitor: i32) -> Vector2;
    fun GetMonitorWidth(monitor: i32);
    fun GetMonitorHeight(monitor: i32);
    fun GetMonitorPhysicalWidth(monitor: i32);
    fun GetMonitorPhysicalHeight(monitor: i32);
    fun GetMonitorRefreshRate(monitor: i32);
    fun GetWindowPosition() -> Vector2;
    fun GetWindowScaleDPI() -> Vector2;
    fun GetMonitorName(monitor: i32) -> ptr<i8>;
    fun SetClipboardText(text: ptr<i8>);
    fun GetClipboardText() -> ptr<i8>;
    fun GetClipboardImage() -> Image;
    fun EnableEventWaiting();
    fun DisableEventWaiting();
    fun ShowCursor();
    fun HideCursor();
    fun IsCursorHidden() -> bool;
    fun EnableCursor();
    fun DisableCursor();
    fun IsCursorOnScreen() -> bool;
    fun ClearBackground(color: Color);
    fun BeginDrawing();
    fun EndDrawing();
    fun BeginMode2D(camera: Camera2D);
    fun EndMode2D();
    fun BeginMode3D(camera: Camera3D);
    fun EndMode3D();
    fun BeginTextureMode(target: RenderTexture2D);
    fun EndTextureMode();
    fun BeginShaderMode(shader: Shader);
    fun EndShaderMode();
    fun BeginBlendMode(mode: i32);
    fun EndBlendMode();
    fun BeginScissorMode(x: i32, y: i32, width: i32, height: i32);
    fun EndScissorMode();
    fun BeginVrStereoMode(config: VrStereoConfig);
    fun EndVrStereoMode();
    fun LoadVrStereoConfig(device: VrDeviceInfo) -> VrStereoConfig;
    fun UnloadVrStereoConfig(config: VrStereoConfig);
    fun LoadShader(vsFileName: ptr<i8>, fsFileName: ptr<i8>) -> Shader;
    fun LoadShaderFromMemory(vsCode: ptr<i8>, fsCode: ptr<i8>) -> Shader;
    fun IsShaderValid(shader: Shader) -> bool;
    fun GetShaderLocation(shader: Shader, uniformName: ptr<i8>) -> i32;
    fun GetShaderLocationAttrib(shader: Shader, attribName: ptr<i8>) -> i32;
    fun SetShaderValue(shader: Shader, locIndex: i32, value: ptr<u8>, uniformType: i32);
    fun SetShaderValueV(shader: Shader, locIndex: i32, value: ptr<u8>, uniformType: i32, count: i32);
    fun SetShaderValueMatrix(shader: Shader, locIndex: i32, mat: Matrix);
    fun SetShaderValueTexture(shader: Shader, locIndex: i32, texture: Texture2D);
    fun UnloadShader(shader: Shader);
    fun GetScreenToWorldRay(position: Vector2, camera: Camera) -> Ray;
    fun GetScreenToWorldRayEx(position: Vector2, camera: Camera, width: i32, height: i32) -> Ray;
    fun GetWorldToScreen(position: Vector3, camera: Camera) -> Vector2;
    fun GetWorldToScreenEx(position: Vector3, camera: Camera, width: i32, height: i32) -> Vector2;
    fun GetWorldToScreen2D(position: Vector2, camera: Camera2D) -> Vector2;
    fun GetScreenToWorld2D(position: Vector2, camera: Camera2D) -> Vector2;
    fun GetCameraMatrix(camera: Camera) -> Matrix;
    fun GetCameraMatrix2D(camera: Camera2D) -> Matrix;
    fun SetTargetFPS(fps: i32);
    fun GetFrameTime() -> f32;
    fun GetTime() -> f64;
    fun GetFPS() -> i32;
    fun SwapScreenBuffer();
    fun PollInputEvents();
    fun WaitTime(seconds: f64);
    fun SetRandomSeed(seed: u32);
    fun GetRandomValue(min: i32, max: i32) -> i32;
    fun LoadRandomSequence(count: u32, min: i32, max: i32) -> ptr<i32>;
    fun UnloadRandomSequence(sequence: ptr<i32>);
    fun TakeScreenshot(fileName: ptr<i8>);
    fun SetConfigFlags(flags: u32);
    fun OpenURL(url: ptr<i8>);
    fun SetTraceLogLevel(logLevel: i32);
    fun TraceLog(logLevel: i32, text: ptr<i8>);
    fun SetTraceLogCallback(callback: TraceLogCallback);
    fun MemAlloc(size: u32) -> ptr<u8>;
    fun MemRealloc(ptr: ptr<u8>, size: u32) -> ptr<u8>;
    fun MemFree(ptr: ptr<u8>);
    fun LoadFileData(fileName: ptr<i8>, dataSize: ptr<i32>) -> ptr<i8>;
    fun UnloadFileData(data: ptr<i8>);
    fun SaveFileData(fileName: ptr<i8>, data: ptr<u8>, dataSize: i32) -> bool;
    fun ExportDataAsCode(data: ptr<u8>, dataSize: i32, fileName: ptr<i8>) -> bool;
    fun LoadFileText(fileName: ptr<i8>) -> ptr<i8>;
    fun UnloadFileText(text: ptr<i8>);
    fun SaveFileText(fileName: ptr<i8>, text: ptr<i8>) -> bool;
    fun SetLoadFileDataCallback(callback: LoadFileDataCallback);
    fun SetSaveFileDataCallback(callback: SaveFileDataCallback);
    fun SetLoadFileTextCallback(callback: LoadFileTextCallback);
    fun SetSaveFileTextCallback(callback: SaveFileTextCallback);
    fun FileRename(fileName: ptr<i8>, fileRename: ptr<i8>) -> i32;
    fun FileRemove(*fileName: const char) -> i32;
    fun FileCopy(srcPath: ptr<i8>, dstPath: ptr<i8>) -> i32;
    fun FileMove(srcPath: ptr<i8>, dstPath: ptr<i8>) -> i32;
    fun FileTextReplace(fileName: ptr<i8>, search: ptr<i8>, replacement: ptr<i8>) -> i32;
    fun FileTextFindIndex(*fileName: const char, *search: const char) -> i32;
    fun FileExists(fileName: ptr<i8>) -> bool;
    fun DirectoryExists(dirPath: ptr<i8>) -> bool;
    fun IsFileExtension(fileName: ptr<i8>, ext: ptr<i8>) -> bool;
    fun GetFileLength(fileName: ptr<i8>) -> i32;
    fun GetFileModTime(*fileName: ptr<i8>) -> i64;
    fun GetFileExtension(fileName: ptr<i8>) -> ptr<i8>;
    fun GetFileName(filePath: ptr<i8>) -> ptr<i8>;
    fun GetFileNameWithoutExt(filePath: ptr<i8>) -> ptr<i8>;
    fun GetDirectoryPath(filePath: ptr<i8>) -> ptr<i8>;
    fun GetPrevDirectoryPath(dirPath: ptr<i8>) -> ptr<i8>;
    fun GetWorkingDirectory() -> ptr<i8>;
    fun GetApplicationDirectory() -> ptr<i8>;
    fun MakeDirectory(dirPath: ptr<i8>) -> i32;
    fun ChangeDirectory(dirPath: ptr<i8>) -> bool;
    fun IsPathFile(path: ptr<i8>) -> bool;
    fun IsFileNameValid(fileName: ptr<i8>) -> bool;
    fun LoadDirectoryFiles(dirPath: ptr<i8>) -> FilePathList;
    fun LoadDirectoryFilesEx(basePath: ptr<i8>, filter: ptr<i8>, scanSubdirs: bool) -> FilePathList;
    fun UnloadDirectoryFiles(files: FilePathList);
    fun IsFileDropped() -> bool;
    fun LoadDroppedFiles() -> FilePathList;
    fun UnloadDroppedFiles(files: FilePathList);
    fun GetDirectoryFileCount(dirPath: ptr<i8>) -> u32;
    fun GetDirectoryFileCountEx(basePath: ptr<i8>, filter: ptr<i8>, scanSubdirs: bool) -> u32;
    fun CompressData(data: ptr<u8>, dataSize: i32, compDataSize: ptr<i32>) -> ptr<u8>;
    fun DecompressData(compData: ptr<u8>, compDataSize: i32, dataSize: ptr<i32>) -> ptr<u8>;
    fun EncodeDataBase64(data: ptr<u8>, dataSize: i32, outputSize: ptr<i32>) -> ptr<i8>;
    fun DecodeDataBase64(text: ptr<i8>, outputSize: ptr<i32>) -> ptr<u8>;
    fun ComputeCRC32(data: ptr<u8>, dataSize: i32) -> u8;
    fun ComputeMD5(data: ptr<u8>, dataSize: i32) -> ptr<u8>;
    fun ComputeSHA1(data: ptr<u8>, dataSize: i32) -> ptr<u8>;
    fun ComputeSHA256(data: ptr<u8>, dataSize: i32) -> ptr<u8>;
    fun LoadAutomationEventList(fileName: ptr<i8>) -> AutomationEventList;
    fun UnloadAutomationEventList(list: AutomationEventList);
    fun ExportAutomationEventList(list: AutomationEventList, fileName: ptr<i8>) -> bool;
    fun SetAutomationEventList(list: ptr<AutomationEventList>);
    fun SetAutomationEventBaseFrame(frame: i32);
    fun StartAutomationEventRecording();
    fun StopAutomationEventRecording();
    fun PlayAutomationEvent(event: AutomationEvent);
    fun IsKeyPressed(key: i32) -> bool;
    fun IsKeyPressedRepeat(key: i32) -> bool;
    fun IsKeyDown(key: i32) -> bool;
    fun IsKeyReleased(key: i32) -> bool;
    fun IsKeyUp(key: i32) -> bool;
    fun GetKeyPressed() -> i32;
    fun GetCharPressed() -> i32;
    fun GetKeyName(key: i32) -> ptr<i8>;
    fun SetExitKey(key: i32);
    fun IsGamepadAvailable(gamepad: i32) -> bool;
    fun GetGamepadName(gamepad: i32) -> ptr<i8>;
    fun IsGamepadButtonPressed(gamepad: i32, button: i32) -> bool;
    fun IsGamepadButtonDown(gamepad: i32, button: i32) -> bool;
    fun IsGamepadButtonReleased(gamepad: i32, button: i32) -> bool;
    fun IsGamepadButtonUp(gamepad: i32, button: i32) -> bool;
    fun GetGamepadButtonPressed() -> i32;
    fun GetGamepadAxisCount(gamepad: i32) -> i32;
    fun GetGamepadAxisMovement(gamepad: i32, axis: i32) -> f32;
    fun SetGamepadMappings(mappings: ptr<i8>) -> i32;
    fun SetGamepadVibration(gamepad: i32, leftMotor: f32, rightMotor: f32, duration: f32);
    fun IsMouseButtonPressed(button: i32) -> bool;
    fun IsMouseButtonDown(button: i32) -> bool;
    fun IsMouseButtonReleased(button: i32) -> bool;
    fun IsMouseButtonUp(button: i32) -> bool;
    fun GetMouseX() -> i32;
    fun GetMouseY() -> i32;
    fun GetMousePosition() -> Vector2;
    fun GetMouseDelta() -> Vector2;
    fun SetMousePosition(x: i32, y: i32);
    fun SetMouseOffset(offsetX: i32, offsetY: i32);
    fun SetMouseScale(scaleX: f32, scaleY: f32);
    fun GetMouseWheelMove() -> f32;
    fun GetMouseWheelMoveV() -> Vector2;
    fun SetMouseCursor(cursor: i32);
    fun GetTouchX() -> i32;
    fun GetTouchY() -> i32;
    fun GetTouchPosition(index: i32) -> Vector2;
    fun GetTouchPointId(index: i32) -> i32;
    fun GetTouchPointCount() -> i32;
    fun SetGesturesEnabled(flags: u32);
    fun IsGestureDetected(gesture: u32) -> bool;
    fun GetGestureDetected() -> i32;
    fun GetGestureHoldDuration() -> f32;
    fun GetGestureDragVector() -> Vector2;
    fun GetGestureDragAngle() -> f32;
    fun GetGesturePinchVector() -> Vector2;
    fun GetGesturePinchAngle() -> f32;
    fun UpdateCamera(camera: ptr<Camera>, mode: i32);
    fun UpdateCameraPro(camera: ptr<Camera>, movement: Vector3, rotation: Vector3, zoom: f32);
    fun SetShapesTexture(texture: Texture2D, source: Rectangle);
    fun GetShapesTexture() -> Texture2D;
    fun GetShapesTextureRectangle() -> Rectangle;
    fun DrawPixel(posX: i32, posY: i32, color: Color);
    fun DrawPixelV(position: Vector2, color: Color);
    fun DrawLine(startPosX: i32, startPosY: i32, endPosX: i32, endPosY: i32, color: Color);
    fun DrawLineV(startPos: Vector2, endPos: Vector2, color: Color);
    fun DrawLineEx(startPos: Vector2, endPos: Vector2, thick: i32, color: Color);
    fun DrawLineStrip(points: ptr<Vector2>, pointCount: i32, color: Color);
    fun DrawLineBezier(startPos: Vector2, endPos: Vector2, thick: f32, color: Color);
    fun DrawLineDashed(startPos: Vector2, endPos: Vector2, dashSize: i32, spaceSize: i32, color: Color);
    fun DrawCircle(centerX: i32, centerY: i32, radius: f32, color: Color);
    fun DrawCircleSector(center: Vector2, radius: f32, startAngle: f32, endAngle: f32, segments: i32, color: Color);
    fun DrawCircleSectorLines(center: Vector2, radius: f32, startAngle: f32, endAngle: f32, segments: i32, color: Color);
    fun DrawCircleGradient(centerX: i32, centerY: i32, radius: f32, inner: Color, outer: Color);
    fun DrawCircleV(center: Vector2, radius: f32, color: Color);
    fun DrawCircleLines(centerX: i32, centerY: i32, radius: f32, color: Color);
    fun DrawCircleLinesV(center: Vector2, radius: f32, color: Color);
    fun DrawEllipse(centerX: i32, centerY: i32, radiusH: f32, radiusV: f32, color: Color);
    fun DrawEllipseV(center: Vector2, radiusH: f32, radiusV: f32, color: Color);
    fun DrawEllipseLines(centerX: i32, centerY: i32, radiusH: f32, radiusV: f32, color: Color);
    fun DrawEllipseLinesV(center: Vector2, radiusH: f32, radiusV: f32, color: Color);
    fun DrawRing(center: Vector2, innerRadius: f32, outerRadius: f32, startAngle: f32, endAngle: f32, segments: i32, color: Color);
    fun DrawRingLines(center: Vector2, innerRadius: i32, outerRadius: f32, startAngle: f32, endAngle: f32, segments: i32, color: Color);
    fun DrawRectangle(posX: i32, posY: i32, width: i32, height: i32, color: Color);
    fun DrawRectangleV(position: Vector2, size: Vector2, color: Color);
    fun DrawRectangleRec(rec: Rectangle, color: Color);
    fun DrawRectanglePro(rec: Rectangle, origin: Vector2, rotation: i32, color: Color);
    fun DrawRectangleGradientV(posX: i32, posY: i32, width: i32, height: i32, top: Color, bottom: Color);
    fun DrawRectangleGradientH(posX: i32, posY: i32, width: i32, height: i32, left: Color, right: Color);
    fun DrawRectangleGradientEx(rec: Rectangle, topLeft: Color, bottomLeft: Color, bottomRight: Color, topRight: Color);
    fun DrawRectangleLines(posX: i32, posY: i32, width: i32, height: i32, color: Color);
    fun DrawRectangleLinesEx(rec: Rectangle, lineThick: i32, color: Color);
    fun DrawRectangleRounded(rec: Rectangle, roundness: i32, segments: i32, color: Color);
    fun DrawRectangleRoundedLines(rec: Rectangle, roundness: i32, segments: i32, color: Color);
    fun DrawRectangleRoundedLinesEx(rec: Rectangle, roundness: i32, segments: i32, lineThick: i32, color: Color);
    fun DrawTriangle(v1: Vector2, v2: Vector2, v3: Vector2, color: Color);
    fun DrawTriangleLines(v1: Vector2, v2: Vector2, v3: Vector2, color: Color);
    fun DrawTriangleFan(points: ptr<Vector2>, pointCount: i32, color: Color);
    fun DrawTriangleStrip(points: ptr<Vector2>, pointCount: i32, color: Color);
    fun DrawPoly(center: Vector2, sides: i32, radius: i32, rotation: i32, color: Color);
    fun DrawPolyLines(center: Vector2, sides: i32, radius: i32, rotation: i32, color: Color);
    fun DrawPolyLinesEx(center: Vector2, sides: i32, radius: i32, rotation: i32, lineThick: i32, color: Color);
    fun DrawSplineLinear(points: ptr<Vector2>, pointCount: i32, thick: i32, color: Color);
    fun DrawSplineBasis(points: ptr<Vector2>, pointCount: i32, thick: i32, color: Color);
    fun DrawSplineCatmullRom(points: ptr<Vector2>, pointCount: i32, thick: i32, color: Color);
    fun DrawSplineBezierQuadratic(points: ptr<Vector2>, pointCount: i32, thick: i32, color: Color);
    fun DrawSplineBezierCubic(points: ptr<Vector2>, pointCount: i32, thick: i32, color: Color);
    fun DrawSplineSegmentLinear(p1: Vector2, p2: Vector2, thick: i32, color: Color);
    fun DrawSplineSegmentBasis(p1: Vector2, p2: Vector2, p3: Vector2, p4: Vector2, thick: i32, color: Color);
    fun DrawSplineSegmentCatmullRom(p1: Vector2, p2: Vector2, p3: Vector2, p4: Vector2, thick: i32, color: Color);
    fun DrawSplineSegmentBezierQuadratic(p1: Vector2, c2: Vector2, p3: Vector2, thick: i32, color: Color);
    fun DrawSplineSegmentBezierCubic(p1: Vector2, c2: Vector2, c3: Vector2, p4: Vector2, thick: i32, color: Color);
    fun GetSplinePointLinear(startPos: Vector2, endPos: Vector2, t: i32) -> Vector2;
    fun GetSplinePointBasis(p1: Vector2, p2: Vector2, p3: Vector2, p4: Vector2, t: i32) -> Vector2;
    fun GetSplinePointCatmullRom(p1: Vector2, p2: Vector2, p3: Vector2, p4: Vector2, t: i32) -> Vector2;
    fun GetSplinePointBezierQuad(p1: Vector2, c2: Vector2, p3: Vector2, t: i32) -> Vector2;
    fun GetSplinePointBezierCubic(p1: Vector2, c2: Vector2, c3: Vector2, p4: Vector2, t: i32) -> Vector2;
    fun CheckCollisionRecs(rec1: Rectangle, rec2: Rectangle) -> bool;
    fun CheckCollisionCircles(center1: Vector2, radius1: i32, center2: Vector2, radius2: i32) -> bool;
    fun CheckCollisionCircleRec(center: Vector2, radius: i32, rec: Rectangle) -> bool;
    fun CheckCollisionCircleLine(center: Vector2, radius: i32, p1: Vector2, p2: Vector2) -> bool;
    fun CheckCollisionPointRec(point: Vector2, rec: Rectangle) -> bool;
    fun CheckCollisionPointCircle(point: Vector2, center: Vector2, radius: i32) -> bool;
    fun CheckCollisionPointTriangle(point: Vector2, p1: Vector2, p2: Vector2, p3: Vector2) -> bool;
    fun CheckCollisionPointLine(point: Vector2, p1: Vector2, p2: Vector2, threshold: i32) -> bool;
    fun CheckCollisionPointPoly(point: Vector2, points: ptr<Vector2>, pointCount: i32) -> bool;
    fun CheckCollisionLines(startPos1: Vector2, endPos1: Vector2, startPos2: Vector2, endPos2: Vector2, collisionPoint: ptr<Vector2>) -> bool;
    fun GetCollisionRec(rec1: Rectangle, rec2: Rectangle) -> Rectangle;
    fun LoadImage(fileName: ptr<i8>) -> Image;
    fun LoadImageRaw(fileName: ptr<i8>, width: i32, height: i32, format: i32, headerSize: i32) -> Image;
    fun LoadImageAnim(fileName: ptr<i8>, frames: ptr<i32>) -> Image;
    fun LoadImageAnimFromMemory(fileType: ptr<i8>, fileData: ptr<u8>, dataSize: i32, frames: ptr<i32>) -> Image;
    fun LoadImageFromMemory(fileType: ptr<i8>, fileData: ptr<u8>, dataSize: i32) -> Image;
    fun LoadImageFromTexture(texture: Texture2D) -> Image;
    fun LoadImageFromScreen() -> Image;
    fun IsImageValid(image: Image) -> bool;
    fun UnloadImage(image: Image);
    fun ExportImage(image: Image, fileName: ptr<i8>) -> bool;
    fun ExportImageToMemory(image: Image, fileType: ptr<i8>, fileSize: ptr<i32>) -> ptr<u8>;
    fun ExportImageAsCode(image: Image, fileName: ptr<i8>) -> bool;
    fun GenImageColor(width: i32, height: i32, color: Color) -> Image;
    fun GenImageGradientLinear(width: i32, height: i32, direction: i32, start: Color, end: Color) -> Image;
    fun GenImageGradientRadial(width: i32, height: i32, density: i32, inner: Color, outer: Color) -> Image;
    fun GenImageGradientSquare(width: i32, height: i32, density: i32, inner: Color, outer: Color) -> Image;
    fun GenImageChecked(width: i32, height: i32, checksX: i32, checksY: i32, col1: Color, col2: Color) -> Image;
    fun GenImageWhiteNoise(width: i32, height: i32, factor: i32) -> Image;
    fun GenImagePerlinNoise(width: i32, height: i32, offsetX: i32, offsetY: i32, scale: i32) -> Image;
    fun GenImageCellular(width: i32, height: i32, tileSize: i32) -> Image;
    fun GenImageText(width: i32, height: i32, text: ptr<i8>) -> Image;
    fun ImageCopy(image: Image) -> Image;
    fun ImageFromImage(image: Image, rec: Rectangle) -> Image;
    fun ImageFromChannel(image: Image, selectedChannel: i32) -> Image;
    fun ImageText(text: ptr<i8>, fontSize: i32, color: Color) -> Image;
    fun ImageTextEx(font: Font, text: ptr<i8>, fontSize: i32, spacing: i32, tint: Color) -> Image;
    fun ImageFormat(image: ptr<Image>, newFormat: i32);
    fun ImageToPOT(image: ptr<Image>, fill: Color);
    fun ImageCrop(image: ptr<Image>, crop: Rectangle);
    fun ImageAlphaCrop(image: ptr<Image>, threshold: i32);
    fun ImageAlphaClear(image: ptr<Image>, color: Color, threshold: i32);
    fun ImageAlphaMask(image: ptr<Image>, alphaMask: Image);
    fun ImageAlphaPremultiply(image: ptr<Image>);
    fun ImageBlurGaussian(image: ptr<Image>, blurSize: i32);
    fun ImageKernelConvolution(image: ptr<Image>, kernel: ptr<i32>, kernelSize: i32);
    fun ImageResize(image: ptr<Image>, newWidth: i32, newHeight: i32);
    fun ImageResizeNN(image: ptr<Image>, newWidth: i32, newHeight: i32);
    fun ImageResizeCanvas(image: ptr<Image>, newWidth: i32, newHeight: i32, offsetX: i32, offsetY: i32, fill: Color);
    fun ImageMipmaps(image: ptr<Image>);
    fun ImageDither(image: ptr<Image>, rBpp: i32, gBpp: i32, bBpp: i32, aBpp: i32);
    fun ImageFlipVertical(image: ptr<Image>);
    fun ImageFlipHorizontal(image: ptr<Image>);
    fun ImageRotate(image: ptr<Image>, degrees: i32);
    fun ImageRotateCW(image: ptr<Image>);
    fun ImageRotateCCW(image: ptr<Image>);
    fun ImageColorTint(image: ptr<Image>, color: Color);
    fun ImageColorInvert(image: ptr<Image>);
    fun ImageColorGrayscale(image: ptr<Image>);
    fun ImageColorContrast(image: ptr<Image>, contrast: i32);
    fun ImageColorBrightness(image: ptr<Image>, brightness: i32);
    fun ImageColorReplace(image: ptr<Image>, color: Color, replace: Color);
    fun LoadImageColors(image: Image) -> ptr<Color>;
    fun LoadImagePalette(image: Image, maxPaletteSize: i32, colorCount: ptr<i32>) -> ptr<Color>;
    fun UnloadImageColors(colors: ptr<Color>);
    fun UnloadImagePalette(colors: ptr<Color>);
    fun GetImageAlphaBorder(image: Image, threshold: i32) -> Rectangle;
    fun GetImageColor(image: Image, x: i32, y: i32) -> Color;
    fun ImageClearBackground(dst: ptr<Image>, color: Color);
    fun ImageDrawPixel(dst: ptr<Image>, posX: i32, posY: i32, color: Color);
    fun ImageDrawPixelV(dst: ptr<Image>, position: Vector2, color: Color);
    fun ImageDrawLine(dst: ptr<Image>, startPosX: i32, startPosY: i32, endPosX: i32, endPosY: i32, color: Color);
    fun ImageDrawLineV(dst: ptr<Image>, start: Vector2, end: Vector2, color: Color);
    fun ImageDrawLineEx(dst: ptr<Image>, start: Vector2, end: Vector2, thick: i32, color: Color);
    fun ImageDrawCircle(dst: ptr<Image>, centerX: i32, centerY: i32, radius: i32, color: Color);
    fun ImageDrawCircleV(dst: ptr<Image>, center: Vector2, radius: i32, color: Color);
    fun ImageDrawCircleLines(dst: ptr<Image>, centerX: i32, centerY: i32, radius: i32, color: Color);
    fun ImageDrawCircleLinesV(dst: ptr<Image>, center: Vector2, radius: i32, color: Color);
    fun ImageDrawRectangle(dst: ptr<Image>, posX: i32, posY: i32, width: i32, height: i32, color: Color);
    fun ImageDrawRectangleV(dst: ptr<Image>, position: Vector2, size: Vector2, color: Color);
    fun ImageDrawRectangleRec(dst: ptr<Image>, rec: Rectangle, color: Color);
    fun ImageDrawRectangleLines(dst: ptr<Image>, rec: Rectangle, thick: i32, color: Color);
    fun ImageDrawTriangle(dst: ptr<Image>, v1: Vector2, v2: Vector2, v3: Vector2, color: Color);
    fun ImageDrawTriangleEx(dst: ptr<Image>, v1: Vector2, v2: Vector2, v3: Vector2, c1: Color, c2: Color, c3: Color);
    fun ImageDrawTriangleLines(dst: ptr<Image>, v1: Vector2, v2: Vector2, v3: Vector2, color: Color);
    fun ImageDrawTriangleFan(dst: ptr<Image>, points: ptr<Vector2>, pointCount: i32, color: Color);
    fun ImageDrawTriangleStrip(dst: ptr<Image>, points: ptr<Vector2>, pointCount: i32, color: Color);
    fun ImageDraw(dst: ptr<Image>, src: Image, srcRec: Rectangle, dstRec: Rectangle, tint: Color);
    fun ImageDrawText(dst: ptr<Image>, text: ptr<i8>, posX: i32, posY: i32, fontSize: i32, color: Color);
    fun ImageDrawTextEx(dst: ptr<Image>, font: Font, text: ptr<i8>, position: Vector2, fontSize: i32, spacing: i32, tint: Color);
    fun LoadTexture(fileName: ptr<i8>) -> Texture2D;
    fun LoadTextureFromImage(image: Image) -> Texture2D;
    fun LoadTextureCubemap(image: Image, layout: i32) -> TextureCubemap;
    fun LoadRenderTexture(width: i32, height: i32) -> RenderTexture2D;
    fun IsTextureValid(texture: Texture2D) -> bool;
    fun UnloadTexture(texture: Texture2D);
    fun IsRenderTextureValid(target: RenderTexture2D) -> bool;
    fun UnloadRenderTexture(target: RenderTexture2D);
    fun UpdateTexture(texture: Texture2D, pixels: ptr<u8>);
    fun UpdateTextureRec(texture: Texture2D, rec: Rectangle, pixels: ptr<u8>);
    fun GenTextureMipmaps(texture: ptr<Texture2D>);
    fun SetTextureFilter(texture: Texture2D, filter: i32);
    fun SetTextureWrap(texture: Texture2D, wrap: i32);
    fun DrawTexture(texture: Texture2D, posX: i32, posY: i32, tint: Color);
    fun DrawTextureV(texture: Texture2D, position: Vector2, tint: Color);
    fun DrawTextureEx(texture: Texture2D, position: Vector2, rotation: i32, scale: i32, tint: Color);
    fun DrawTextureRec(texture: Texture2D, source: Rectangle, position: Vector2, tint: Color);
    fun DrawTexturePro(texture: Texture2D, source: Rectangle, dest: Rectangle, origin: Vector2, rotation: i32, tint: Color);
    fun DrawTextureNPatch(texture: Texture2D, nPatchInfo: NPatchInfo, dest: Rectangle, origin: Vector2, rotation: i32, tint: Color);
    fun ColorIsEqual(col1: Color, col2: Color) -> bool;
    fun Fade(color: Color, alpha: i32) -> Color;
    fun ColorToInt(color: Color) -> i32;
    fun ColorNormalize(color: Color) -> Vector4;
    fun ColorFromNormalized(normalized: Vector4) -> Color;
    fun ColorToHSV(color: Color) -> Vector3;
    fun ColorFromHSV(hue: i32, saturation: i32, value: i32) -> Color;
    fun ColorTint(color: Color, tint: Color) -> Color;
    fun ColorBrightness(color: Color, factor: i32) -> Color;
    fun ColorContrast(color: Color, contrast: i32) -> Color;
    fun ColorAlpha(color: Color, alpha: i32) -> Color;
    fun ColorAlphaBlend(dst: Color, src: Color, tint: Color) -> Color;
    fun ColorLerp(color1: Color, color2: Color, factor: i32) -> Color;
    fun GetColor(hexValue: unsigned i32) -> Color;
    fun GetPixelColor(srcPtr: ptr<u8>, format: i32) -> Color;
    fun SetPixelColor(dstPtr: ptr<u8>, color: Color, format: i32);
    fun GetPixelDataSize(width: i32, height: i32, format: i32) -> i32;
    fun GetFontDefault() -> Font;
    fun LoadFont(fileName: ptr<i8>) -> Font;
    fun LoadFontEx(fileName: ptr<i8>, fontSize: i32, codepoints: ptr<i32>, codepointCount: i32) -> Font;
    fun LoadFontFromImage(image: Image, key: Color, firstChar: i32) -> Font;
    fun LoadFontFromMemory(fileType: ptr<i8>, fileData: ptr<u8>, dataSize: i32, fontSize: i32, *codepoints: const i32, codepointCount: i32) -> Font;
    fun IsFontValid(font: Font) -> bool;
    fun LoadFontData(fileData: ptr<u8>, dataSize: i32, fontSize: i32, codepoints ptr<i32>, i32 codepointCount, type: i32, glyphCount: ptr<i32>) -> ptr<GlyphInfo>;
    fun GenImageFontAtlas(glyphs: ptr<GlyphInfo>, glyphRecs: ptr<ptr<Rectangle>>, glyphCount: i32, fontSize: i32, padding: i32, packMethod: i32) -> Image;
    fun UnloadFontData(glyphs: ptr<GlyphInfo>, glyphCount: i32);
    fun UnloadFont(font: Font);
    fun ExportFontAsCode(font: Font, fileName: ptr<i8>) -> bool;
    fun DrawFPS(posX: i32, posY: i32);
    fun DrawText(text: ptr<i8>, posX: i32, posY: i32, fontSize: i32, color: Color);
    fun DrawTextEx(font: Font, text: ptr<i8>, position: Vector2, fontSize: i32, spacing: i32, tint: Color);
    fun DrawTextPro(font: Font, text: ptr<i8>, position: Vector2, origin: Vector2, rotation: i32, fontSize: i32, spacing: i32, tint: Color);
    fun DrawTextCodepoint(font: Font, codepoint: i32, position: Vector2, fontSize: i32, tint: Color);
    fun DrawTextCodepoints(font: Font, codepoints: ptr<i32>, codepointCount: i32, position: Vector2, fontSize: i32, spacing: i32, tint: Color);
    fun SetTextLineSpacing(spacing: i32);
    fun MeasureText(text: ptr<i8>, fontSize: i32) -> i32;
    fun MeasureTextEx(font: Font, text: ptr<i8>, fontSize: i32, spacing: i32) -> Vector2;
    fun GetGlyphIndex(font: Font, codepoint: i32) -> i32;
    fun GetGlyphInfo(font: Font, codepoint: i32) -> GlyphInfo;
    fun GetGlyphAtlasRec(font: Font, codepoint: i32) -> Rectangle;
    fun LoadUTF8(codepoints: ptr<i32>, length: i32) -> ptr<i8>;
    fun UnloadUTF8(text: ptr<i8>);
    fun LoadCodepoints(text: ptr<i8>, count: ptr<i32>) -> ptr<i32>;
    fun UnloadCodepoints(codepoints: ptr<i32>);
    fun GetCodepointCount(text: ptr<i8>) -> i32;
    fun GetCodepoint(text: ptr<i8>, codepointSize: ptr<i32>) -> i32;
    fun GetCodepointNext(text: ptr<i8>, codepointSize: ptr<i32>) -> i32;
    fun GetCodepointPrevious(text: ptr<i8>, codepointSize: ptr<i32>) -> i32;
    fun CodepointToUTF8(codepoint: i32, utf8Size: ptr<i32>) -> ptr<i8>;
    fun LoadTextLines(text: ptr<i8>, count: ptr<i32>) -> ptr<ptr<i8>>;
    fun UnloadTextLines(text: ptr<ptr<i8>>, lineCount: i32);
    fun TextCopy(dst: ptr<i8>, src: ptr<i8>) -> i32;
    fun TextIsEqual(text1: ptr<i8>, text2: ptr<i8>) -> bool;
    fun TextLength(text: ptr<i8>) -> u32;
    fun TextSubtext(text: ptr<i8>, position: i32, length: i32) -> ptr<i8>;
    fun TextRemoveSpaces(text: ptr<i8>) -> ptr<i8>;
    fun GetTextBetween(text: ptr<i8>, begin: ptr<i8>, end: ptr<i8>) -> ptr<i8>;
    fun TextReplace(text: ptr<i8>, search: ptr<i8>, replacement: ptr<i8>) -> ptr<i8>;
    fun TextReplaceBetween(text: ptr<i8>, begin: ptr<i8>, end: ptr<i8>, replacement: ptr<i8>) -> ptr<i8>;
    fun TextInsert(text: ptr<i8>, insert: ptr<i8>, position: i32) -> ptr<i8>;
    fun TextJoin(textList: ptr<ptr<i8>>, count: i32, delimiter: ptr<i8>) -> ptr<i8>;
    fun TextSplit(text: ptr<i8>, delimiter: i8, count: ptr<i32>) -> ptr<ptr<i8>>;
    fun TextAppend(text: ptr<i8>, append: ptr<i8>, position: ptr<i32>);
    fun TextFindIndex(text: ptr<i8>, search: ptr<i8>) -> i32;
    fun TextToUpper(text: ptr<i8>) -> ptr<i8>;
    fun TextToLower(text: ptr<i8>) -> ptr<i8>;
    fun TextToPascal(text: ptr<i8>) -> ptr<i8>;
    fun TextToSnake(text: ptr<i8>) -> ptr<i8>;
    fun TextToCamel(text: ptr<i8>) -> ptr<i8>;
    fun TextToInteger(text: ptr<i8>) -> i32;
    fun TextToFloat(text: ptr<i8>) -> i32;
    fun DrawLine3D(startPos: Vector3, endPos: Vector3, color: Color);
    fun DrawPoint3D(position: Vector3, color: Color);
    fun DrawCircle3D(center: Vector3, radius: i32, rotationAxis: Vector3, rotationAngle: i32, color: Color);
    fun DrawTriangle3D(v1: Vector3, v2: Vector3, v3: Vector3, color: Color);
    fun DrawTriangleStrip3D(points: ptr<Vector3>, pointCount: i32, color: Color);
    fun DrawCube(position: Vector3, width: i32, height: i32, length: i32, color: Color);
    fun DrawCubeV(position: Vector3, size: Vector3, color: Color);
    fun DrawCubeWires(position: Vector3, width: i32, height: i32, length: i32, color: Color);
    fun DrawCubeWiresV(position: Vector3, size: Vector3, color: Color);
    fun DrawSphere(centerPos: Vector3, radius: i32, color: Color);
    fun DrawSphereEx(centerPos: Vector3, radius: i32, rings: i32, slices: i32, color: Color);
    fun DrawSphereWires(centerPos: Vector3, radius: i32, rings: i32, slices: i32, color: Color);
    fun DrawCylinder(position: Vector3, radiusTop: i32, radiusBottom: i32, height: i32, slices: i32, color: Color);
    fun DrawCylinderEx(startPos: Vector3, endPos: Vector3, startRadius: i32, endRadius: i32, sides: i32, color: Color);
    fun DrawCylinderWires(position: Vector3, radiusTop: i32, radiusBottom: i32, height: i32, slices: i32, color: Color);
    fun DrawCylinderWiresEx(startPos: Vector3, endPos: Vector3, startRadius: i32, endRadius: i32, sides: i32, color: Color);
    fun DrawCapsule(startPos: Vector3, endPos: Vector3, radius: i32, slices: i32, rings: i32, color: Color);
    fun DrawCapsuleWires(startPos: Vector3, endPos: Vector3, radius: i32, slices: i32, rings: i32, color: Color);
    fun DrawPlane(centerPos: Vector3, size: Vector2, color: Color);
    fun DrawRay(ray: Ray, color: Color);
    fun DrawGrid(slices: i32, spacing: i32);
    fun LoadModel(fileName: ptr<i8>) -> Model;
    fun LoadModelFromMesh(mesh: Mesh) -> Model;
    fun IsModelValid(model: Model) -> bool;
    fun UnloadModel(model: Model);
    fun GetModelBoundingBox(model: Model) -> BoundingBox;
    fun DrawModel(model: Model, position: Vector3, scale: i32, tint: Color);
    fun DrawModelEx(model: Model, position: Vector3, rotationAxis: Vector3, rotationAngle: i32, scale: Vector3, tint: Color);
    fun DrawModelWires(model: Model, position: Vector3, scale: i32, tint: Color);
    fun DrawModelWiresEx(model: Model, position: Vector3, rotationAxis: Vector3, rotationAngle: i32, scale: Vector3, tint: Color);
    fun DrawModelPoints(model: Model, position: Vector3, scale: i32, tint: Color);
    fun DrawModelPointsEx(model: Model, position: Vector3, rotationAxis: Vector3, rotationAngle: i32, scale: Vector3, tint: Color);
    fun DrawBoundingBox(box: BoundingBox, color: Color);
    fun DrawBillboard(camera: Camera, texture: Texture2D, position: Vector3, scale: i32, tint: Color);
    fun DrawBillboardRec(camera: Camera, texture: Texture2D, source: Rectangle, position: Vector3, size: Vector2, tint: Color);
    fun DrawBillboardPro(camera: Camera, texture: Texture2D, source: Rectangle, position: Vector3, up: Vector3, size: Vector2, origin: Vector2, rotation: i32, tint: Color);
    fun UploadMesh(mesh: ptr<Mesh>, dynamic: bool);
    fun UpdateMeshBuffer(mesh: Mesh, index: i32, data: ptr<u8>, dataSize: i32, offset: i32);
    fun UnloadMesh(mesh: Mesh);
    fun DrawMesh(mesh: Mesh, material: Material, transform: Matrix);
    fun DrawMeshInstanced(mesh: Mesh, material: Material, transforms: ptr<Matrix>, instances: i32);
    fun GetMeshBoundingBox(mesh: Mesh) -> BoundingBox;
    fun GenMeshTangents(mesh: ptr<Mesh>);
    fun ExportMesh(mesh: Mesh, fileName: ptr<i8>) -> bool;
    fun ExportMeshAsCode(mesh: Mesh, fileName: ptr<i8>) -> bool;
    fun GenMeshPoly(sides: i32, radius: i32) -> Mesh;
    fun GenMeshPlane(width: i32, length: i32, resX: i32, resZ: i32) -> Mesh;
    fun GenMeshCube(width: i32, height: i32, length: i32) -> Mesh;
    fun GenMeshSphere(radius: i32, rings: i32, slices: i32) -> Mesh;
    fun GenMeshHemiSphere(radius: i32, rings: i32, slices: i32) -> Mesh;
    fun GenMeshCylinder(radius: i32, height: i32, slices: i32) -> Mesh;
    fun GenMeshCone(radius: i32, height: i32, slices: i32) -> Mesh;
    fun GenMeshTorus(radius: i32, size: i32, radSeg: i32, sides: i32) -> Mesh;
    fun GenMeshKnot(radius: i32, size: i32, radSeg: i32, sides: i32) -> Mesh;
    fun GenMeshHeightmap(heightmap: Image, size: Vector3) -> Mesh;
    fun GenMeshCubicmap(cubicmap: Image, cubeSize: Vector3) -> Mesh;
    fun LoadMaterials(fileName: ptr<i8>, materialCount: ptr<i32>) -> ptr<Material>;
    fun LoadMaterialDefault() -> Material;
    fun IsMaterialValid(material: Material) -> bool;
    fun UnloadMaterial(material: Material);
    fun SetMaterialTexture(material: ptr<Material>, mapType: i32, texture: Texture2D);
    fun SetModelMeshMaterial(model: ptr<Model>, meshId: i32, materialId: i32);
    fun LoadModelAnimations(fileName: ptr<i8>, animCount: ptr<i32>) -> ptr<ModelAnimation>;
    fun UpdateModelAnimation(model: Model, anim: ModelAnimation, frame: i32);
    fun UpdateModelAnimationBones(model: Model, anim: ModelAnimation, frame: i32);
    fun UnloadModelAnimation(anim: ModelAnimation);
    fun UnloadModelAnimations(animations: ptr<ModelAnimation>, animCount: i32);
    fun IsModelAnimationValid(model: Model, anim: ModelAnimation) -> bool;
    fun CheckCollisionSpheres(center1: Vector3, radius1: i32, center2: Vector3, radius2: i32) -> bool;
    fun CheckCollisionBoxes(box1: BoundingBox, box2: BoundingBox) -> bool;
    fun CheckCollisionBoxSphere(box: BoundingBox, center: Vector3, radius: i32) -> bool;
    fun GetRayCollisionSphere(ray: Ray, center: Vector3, radius: i32) -> RayCollision;
    fun GetRayCollisionBox(ray: Ray, box: BoundingBox) -> RayCollision;
    fun GetRayCollisionMesh(ray: Ray, mesh: Mesh, transform: Matrix) -> RayCollision;
    fun GetRayCollisionTriangle(ray: Ray, p1: Vector3, p2: Vector3, p3: Vector3) -> RayCollision;
    fun GetRayCollisionQuad(ray: Ray, p1: Vector3, p2: Vector3, p3: Vector3, p4: Vector3) -> RayCollision;
    fun InitAudioDevice();
    fun CloseAudioDevice();
    fun IsAudioDeviceReady() -> bool;
    fun SetMasterVolume(volume: i32);
    fun GetMasterVolume() -> i32;
    fun LoadWave(fileName: ptr<i8>) -> Wave;
    fun LoadWaveFromMemory(fileType: ptr<i8>, fileData: ptr<u8>, dataSize: i32) -> Wave;
    fun IsWaveValid(wave: Wave) -> bool;
    fun LoadSound(fileName: ptr<i8>) -> Sound;
    fun LoadSoundFromWave(wave: Wave) -> Sound;
    fun LoadSoundAlias(source: Sound) -> Sound;
    fun IsSoundValid(sound: Sound) -> bool;
    fun UpdateSound(sound: Sound, data: ptr<u8>, sampleCount: i32);
    fun UnloadWave(wave: Wave);
    fun UnloadSound(sound: Sound);
    fun UnloadSoundAlias(alias: Sound);
    fun ExportWave(wave: Wave, fileName: ptr<i8>) -> bool;
    fun ExportWaveAsCode(wave: Wave, fileName: ptr<i8>) -> bool;
    fun PlaySound(sound: Sound);
    fun StopSound(sound: Sound);
    fun PauseSound(sound: Sound);
    fun ResumeSound(sound: Sound);
    fun IsSoundPlaying(sound: Sound) -> bool;
    fun SetSoundVolume(sound: Sound, volume: i32);
    fun SetSoundPitch(sound: Sound, pitch: i32);
    fun SetSoundPan(sound: Sound, pan: i32);
    fun WaveCopy(wave: Wave) -> Wave;
    fun WaveCrop(wave: ptr<Wave>, initFrame: i32, finalFrame: i32);
    fun WaveFormat(wave: ptr<Wave>, sampleRate: i32, sampleSize: i32, channels: i32);
    fun LoadWaveSamples(wave: Wave) -> ptr<i32>;
    fun UnloadWaveSamples(samples: ptr<i32>);
    fun LoadMusicStream(fileName: ptr<i8>) -> Music;
    fun LoadMusicStreamFromMemory(fileType: ptr<i8>, data: ptr<u8>, dataSize: i32) -> Music;
    fun IsMusicValid(music: Music) -> bool;
    fun UnloadMusicStream(music: Music);
    fun PlayMusicStream(music: Music);
    fun IsMusicStreamPlaying(music: Music) -> bool;
    fun UpdateMusicStream(music: Music);
    fun StopMusicStream(music: Music);
    fun PauseMusicStream(music: Music);
    fun ResumeMusicStream(music: Music);
    fun SeekMusicStream(music: Music, position: i32);
    fun SetMusicVolume(music: Music, volume: i32);
    fun SetMusicPitch(music: Music, pitch: i32);
    fun SetMusicPan(music: Music, pan: i32);
    fun GetMusicTimeLength(music: Music) -> i32;
    fun GetMusicTimePlayed(music: Music) -> i32;
    fun LoadAudioStream(sampleRate: u32, sampleSize: u32, channels: u32) -> AudioStream;
    fun IsAudioStreamValid(stream: AudioStream) -> bool;
    fun UnloadAudioStream(stream: AudioStream);
    fun UpdateAudioStream(stream: AudioStream, data: ptr<u8>, frameCount: i32);
    fun IsAudioStreamProcessed(stream: AudioStream) -> bool;
    fun PlayAudioStream(stream: AudioStream);
    fun PauseAudioStream(stream: AudioStream);
    fun ResumeAudioStream(stream: AudioStream);
    fun IsAudioStreamPlaying(stream: AudioStream) -> bool;
    fun StopAudioStream(stream: AudioStream);
    fun SetAudioStreamVolume(stream: AudioStream, volume: i32);
    fun SetAudioStreamPitch(stream: AudioStream, pitch: i32);
    fun SetAudioStreamPan(stream: AudioStream, pan: i32);
    fun SetAudioStreamBufferSizeDefault(size: i32);
    fun SetAudioStreamCallback(stream: AudioStream, callback: AudioCallback);
    fun AttachAudioStreamProcessor(stream: AudioStream, processor: AudioCallback);
    fun DetachAudioStreamProcessor(stream: AudioStream, processor: AudioCallback);
    fun AttachAudioMixedProcessor(processor: AudioCallback);
    fun DetachAudioMixedProcessor(processor: AudioCallback);
}