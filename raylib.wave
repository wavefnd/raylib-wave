const LIGHTGRAY:  Color = Color { r: 200, g: 200, b: 200, a: 255 };
const GRAY:       Color = Color { r: 130, g: 130, b: 130, a: 255 };
const DARKGRAY:   Color = Color { r: 80,  g: 80,  b: 80,  a: 255 };
const YELLOW:     Color = Color { r: 253, g: 249, b: 0,   a: 255 };
const GOLD:       Color = Color { r: 255, g: 203, b: 0,   a: 255 };
const ORANGE:     Color = Color { r: 255, g: 161, b: 0,   a: 255 };
const PINK:       Color = Color { r: 255, g: 109, b: 194, a: 255 };
const RED:        Color = Color { r: 230, g: 41,  b: 55,  a: 255 };
const MAROON:     Color = Color { r: 190, g: 33,  b: 55,  a: 255 };

const GREEN:      Color = Color { r: 0,   g: 228, b: 48,  a: 255 };
const LIME:       Color = Color { r: 0,   g: 158, b: 47,  a: 255 };
const DARKGREEN:  Color = Color { r: 0,   g: 117, b: 44,  a: 255 };

const SKYBLUE:    Color = Color { r: 102, g: 191, b: 255, a: 255 };
const BLUE:       Color = Color { r: 0,   g: 121, b: 241, a: 255 };
const DARKBLUE:   Color = Color { r: 0,   g: 82,  b: 172, a: 255 };

const PURPLE:     Color = Color { r: 200, g: 122, b: 255, a: 255 };
const VIOLET:     Color = Color { r: 135, g: 60,  b: 190, a: 255 };
const DARKPURPLE: Color = Color { r: 112, g: 31,  b: 126, a: 255 };

const BEIGE:      Color = Color { r: 211, g: 176, b: 131, a: 255 };
const BROWN:      Color = Color { r: 127, g: 106, b: 79,  a: 255 };
const DARKBROWN:  Color = Color { r: 76,  g: 63,  b: 47,  a: 255 };

const WHITE:      Color = Color { r: 255, g: 255, b: 255, a: 255 };
const BLACK:      Color = Color { r: 0,   g: 0,   b: 0,   a: 255 };
const BLANK:      Color = Color { r: 0,   g: 0,   b: 0,   a: 0   };
const MAGENTA:    Color = Color { r: 255, g: 0,   b: 255, a: 255 };
const RAYWHITE:   Color = Color { r: 245, g: 245, b: 245, a: 255 };

struct Vector2 {
    x: f32;
    y: f32;
}

struct Vector3 {
    x: f32;
    y: f32;
    z: f32;
}

struct Vector4 {
    x: f32;
    y: f32;
    z: f32;
    w: f32;
}

type Quaternion = Vector4;

struct Matrix {
    m0: f32;
    m4: f32;
    m8: f32;
    m12: f32;
    m1: f32;
    m5: f32;
    m9: f32;
    m13: f32;
    m2: f32;
    m6: f32;
    m10: f32;
    m14: f32;
    m3: f32;
    m7: f32;
    m11: f32;
    m15: f32;
}

struct Color {
    r: u8;
    g: u8;
    b: u8;
    a: u8;
}

struct Rectangle {
    x: f32;
    y: f32;
    width: f32;
    height: f32;
}

struct Image {
    data: ptr<void>;
    width: i32;
    height: i32;
    mipmaps: i32;
    format: i32;
}

struct Texture {
    id: u32;
    width: i32;
    height: i32;
    mipmaps: i32;
    format: i32;
}

type Texture2D = Texture;
type TextureCubemap = Texture;

struct RenderTexture {
    id: u32;
    texture: Texture;
    depth: Texture;
}

type RenderTexture2D = RenderTexture;

struct NPatchInfo {
    source: Rectangle;
    left: i32;
    top: i32;
    right: i32;
    bottom: i32;
    layout: i32;
}

struct GlyphInfo {
    value: i32;
    offsetX: i32;
    offsetY: i32;
    advanceX: i32;
    image: Image;
}

struct Font {
    baseSize: i32;
    glyphCount: i32;
    glyphPadding: i32;
    texture: Texture2D;
    recs: ptr<Rectangle>;
    glyphs: ptr<GlyphInfo>;
}

struct Camera3D {
    position: Vector3;
    target: Vector3;
    up: Vector3;
    fovy: f32;
    projection: i32;
}

type Camera = Camera3D;

struct Camera2D {
    offset: Vector2;
    target: Vector2;
    rotation: f32;
    zoom: f32;
}


struct Mesh {
    vertexCount: i32;
    triangleCount: i32;
    vertices: ptr<f32>;
    texcoords: ptr<f32>;
    texcoords2: ptr<f32>;
    normals: ptr<f32>;
    tangents: ptr<f32>;
    colors: ptr<u8>;
    indices: ptr<u16>;
    animVertices: ptr<f32>;
    animNormals: ptr<f32>;
    boneIds: ptr<u8>;
    boneWeights: ptr<f32>;
    boneMatrices: ptr<Matrix>;
    boneCount: i32;
    vaoId: u32;
    vboId: ptr<u32>;
}

struct Shader {
    id: u32;
    locs: ptr<i32>;
}

struct MaterialMap {
    texture: Texture2D;
    color: Color;
    value: f32;
}

struct Material {
    shader: Shader;
    maps: ptr<MaterialMap>;
    params: array<f32, 4>;
}

struct Transform {
    translation: Vector3;
    rotation: Quaternion;
    scale: Vector3;
}

struct BoneInfo {
    name: array<i8, 32>;
    parent: i32;
}

struct Model {
    transform: Matrix;
    meshCount: i32;
    materialCount: i32;
    meshes: ptr<Mesh>;
    materials: ptr<Material>;
    meshMaterial: ptr<i32>;
    boneCount: i32;
    bones: ptr<BoneInfo>;
    bindPose: ptr<Transform>;
}

struct ModelAnimation {
    boneCount: i32;
    frameCount: i32;
    bones: ptr<BoneInfo>;
    framePoses: ptr<ptr<Transform>>;
    name: array<i8, 32>;
}

struct Ray {
    position: Vector3;
    direction: Vector3;
}

struct RayCollision {
    hit: bool;
    distance: f32;
    point: Vector3;
    normal: Vector3;
}

struct BoundingBox {
    min: Vector3;
    max: Vector3;
}

struct Wave {
    frameCount: u32;
    sampleRate: u32;
    sampleSize: u32;
    channels: u32;
    data: ptr<void>;
}

type rAudioBuffer = ptr<void>;
type rAudioProcessor = ptr<void>;

struct AudioStream {
    buffer: rAudioBuffer;
    processor: rAudioProcessor;
    sampleRate: u32;
    sampleSize: u32;
    channels: u32;
}

struct Sound {
    stream: AudioStream;
    frameCount: u32;
}

struct Music {
    stream: AudioStream;
    frameCount: u32;
    looping: bool;
    ctxType: i32;
    ctxData: ptr<void>;
}

struct VrDeviceInfo {
    hResolution: i32;
    vResolution: i32;
    hScreenSize: f32;
    vScreenSize: f32;
    eyeToScreenDistance: f32;
    lensSeparationDistance: f32;
    interpupillaryDistance: f32;
    lensDistortionValues: array<f32, 4>;
    chromaAbCorrection: array<f32, 4>;
}

struct VrStereoConfig {
    projection: array<Matrix, 2>;
    viewOffset: array<Matrix, 2>;
    leftLensCenter: array<f32, 2>;
    rightLensCenter: array<f32, 2>;
    leftScreenCenter: array<f32, 2>;
    rightScreenCenter: array<f32, 2>;
    scale: array<f32, 2>;
    scaleIn: array<f32, 2>;
}

struct FilePathList {
    count: u32;
    paths: ptr<ptr<i8>>;
}

struct AutomationEvent {
    frame: u32;
    eventType: u32;
    params: array<i32, 4>;
}

struct AutomationEventList {
    capacity: u32;
    count: u32;
    events: ptr<AutomationEvent>;
}

enum ConfigFlags -> u32 {
    FLAG_VSYNC_HINT         = 0x00000040,
    FLAG_FULLSCREEN_MODE    = 0x00000002,
    FLAG_WINDOW_RESIZABLE   = 0x00000004,
    FLAG_WINDOW_UNDECORATED = 0x00000008,
    FLAG_WINDOW_HIDDEN      = 0x00000080,
    FLAG_WINDOW_MINIMIZED   = 0x00000200,
    FLAG_WINDOW_MAXIMIZED   = 0x00000400,
    FLAG_WINDOW_UNFOCUSED   = 0x00000800,
    FLAG_WINDOW_TOPMOST     = 0x00001000,
    FLAG_WINDOW_ALWAYS_RUN  = 0x00000100,
    FLAG_WINDOW_TRANSPARENT = 0x00000010,
    FLAG_WINDOW_HIGHDPI     = 0x00002000,
    FLAG_WINDOW_MOUSE_PASSTHROUGH = 0x00004000,
    FLAG_BORDERLESS_WINDOWED_MODE = 0x00008000,
    FLAG_MSAA_4X_HINT       = 0x00000020,
    FLAG_INTERLACED_HINT    = 0x00010000
}



enum TraceLogLevel -> i32 {
    LOG_ALL = 0,
    LOG_TRACE,
    LOG_DEBUG,
    LOG_INFO,
    LOG_WARNING,
    LOG_ERROR,
    LOG_FATAL,
    LOG_NONE
}

enum KeyboardKey -> i32 {
    KEY_NULL            = 0,

    KEY_APOSTROPHE      = 39,
    KEY_COMMA           = 44,
    KEY_MINUS           = 45,
    KEY_PERIOD          = 46,
    KEY_SLASH           = 47,
    KEY_ZERO            = 48,
    KEY_ONE             = 49,
    KEY_TWO             = 50,
    KEY_THREE           = 51,
    KEY_FOUR            = 52,
    KEY_FIVE            = 53,
    KEY_SIX             = 54,
    KEY_SEVEN           = 55,
    KEY_EIGHT           = 56,
    KEY_NINE            = 57,
    KEY_SEMICOLON       = 59,
    KEY_EQUAL           = 61,
    KEY_A               = 65,
    KEY_B               = 66,
    KEY_C               = 67,
    KEY_D               = 68,
    KEY_E               = 69,
    KEY_F               = 70,
    KEY_G               = 71,
    KEY_H               = 72,
    KEY_I               = 73,
    KEY_J               = 74,
    KEY_K               = 75,
    KEY_L               = 76,
    KEY_M               = 77,
    KEY_N               = 78,
    KEY_O               = 79,
    KEY_P               = 80,
    KEY_Q               = 81,
    KEY_R               = 82,
    KEY_S               = 83,
    KEY_T               = 84,
    KEY_U               = 85,
    KEY_V               = 86,
    KEY_W               = 87,
    KEY_X               = 88,
    KEY_Y               = 89,
    KEY_Z               = 90,
    KEY_LEFT_BRACKET    = 91,
    KEY_BACKSLASH       = 92,
    KEY_RIGHT_BRACKET   = 93,
    KEY_GRAVE           = 96,

    KEY_SPACE           = 32,
    KEY_ESCAPE          = 256,
    KEY_ENTER           = 257,
    KEY_TAB             = 258,
    KEY_BACKSPACE       = 259,
    KEY_INSERT          = 260,
    KEY_DELETE          = 261,
    KEY_RIGHT           = 262,
    KEY_LEFT            = 263,
    KEY_DOWN            = 264,
    KEY_UP              = 265,
    KEY_PAGE_UP         = 266,
    KEY_PAGE_DOWN       = 267,
    KEY_HOME            = 268,
    KEY_END             = 269,
    KEY_CAPS_LOCK       = 280,
    KEY_SCROLL_LOCK     = 281,
    KEY_NUM_LOCK        = 282,
    KEY_PRINT_SCREEN    = 283,
    KEY_PAUSE           = 284,
    KEY_F1              = 290,
    KEY_F2              = 291,
    KEY_F3              = 292,
    KEY_F4              = 293,
    KEY_F5              = 294,
    KEY_F6              = 295,
    KEY_F7              = 296,
    KEY_F8              = 297,
    KEY_F9              = 298,
    KEY_F10             = 299,
    KEY_F11             = 300,
    KEY_F12             = 301,
    KEY_LEFT_SHIFT      = 340,
    KEY_LEFT_CONTROL    = 341,
    KEY_LEFT_ALT        = 342,
    KEY_LEFT_SUPER      = 343,
    KEY_RIGHT_SHIFT     = 344,
    KEY_RIGHT_CONTROL   = 345,
    KEY_RIGHT_ALT       = 346,
    KEY_RIGHT_SUPER     = 347,
    KEY_KB_MENU         = 348,

    KEY_KP_0            = 320,
    KEY_KP_1            = 321,
    KEY_KP_2            = 322,
    KEY_KP_3            = 323,
    KEY_KP_4            = 324,
    KEY_KP_5            = 325,
    KEY_KP_6            = 326,
    KEY_KP_7            = 327,
    KEY_KP_8            = 328,
    KEY_KP_9            = 329,
    KEY_KP_DECIMAL      = 330,
    KEY_KP_DIVIDE       = 331,
    KEY_KP_MULTIPLY     = 332,
    KEY_KP_SUBTRACT     = 333,
    KEY_KP_ADD          = 334,
    KEY_KP_ENTER        = 335,
    KEY_KP_EQUAL        = 336,

    KEY_BACK            = 4,
    KEY_MENU            = 5,
    KEY_VOLUME_UP       = 24,
    KEY_VOLUME_DOWN     = 25
}

const MOUSE_LEFT_BUTTON: i32   = MOUSE_BUTTON_LEFT;
const MOUSE_RIGHT_BUTTON: i32  = MOUSE_BUTTON_RIGHT;
const MOUSE_MIDDLE_BUTTON: i32 = MOUSE_BUTTON_MIDDLE;

enum MouseButton -> i32 {
    MOUSE_BUTTON_LEFT    = 0,
    MOUSE_BUTTON_RIGHT   = 1,
    MOUSE_BUTTON_MIDDLE  = 2,
    MOUSE_BUTTON_SIDE    = 3,
    MOUSE_BUTTON_EXTRA   = 4,
    MOUSE_BUTTON_FORWARD = 5,
    MOUSE_BUTTON_BACK    = 6,
}

enum MouseCursor -> i32 {
    MOUSE_CURSOR_DEFAULT       = 0,
    MOUSE_CURSOR_ARROW         = 1,
    MOUSE_CURSOR_IBEAM         = 2,
    MOUSE_CURSOR_CROSSHAIR     = 3,
    MOUSE_CURSOR_POINTING_HAND = 4,
    MOUSE_CURSOR_RESIZE_EW     = 5,
    MOUSE_CURSOR_RESIZE_NS     = 6,
    MOUSE_CURSOR_RESIZE_NWSE   = 7,
    MOUSE_CURSOR_RESIZE_NESW   = 8,
    MOUSE_CURSOR_RESIZE_ALL    = 9,
    MOUSE_CURSOR_NOT_ALLOWED   = 10
}


enum GamepadButton -> i32 {
    GAMEPAD_BUTTON_UNKNOWN = 0,
    GAMEPAD_BUTTON_LEFT_FACE_UP,
    GAMEPAD_BUTTON_LEFT_FACE_RIGHT,
    GAMEPAD_BUTTON_LEFT_FACE_DOWN,
    GAMEPAD_BUTTON_LEFT_FACE_LEFT,
    GAMEPAD_BUTTON_RIGHT_FACE_UP,
    GAMEPAD_BUTTON_RIGHT_FACE_RIGHT,
    GAMEPAD_BUTTON_RIGHT_FACE_DOWN,
    GAMEPAD_BUTTON_RIGHT_FACE_LEFT,
    GAMEPAD_BUTTON_LEFT_TRIGGER_1,
    GAMEPAD_BUTTON_LEFT_TRIGGER_2,
    GAMEPAD_BUTTON_RIGHT_TRIGGER_1,
    GAMEPAD_BUTTON_RIGHT_TRIGGER_2,
    GAMEPAD_BUTTON_MIDDLE_LEFT,
    GAMEPAD_BUTTON_MIDDLE,
    GAMEPAD_BUTTON_MIDDLE_RIGHT,
    GAMEPAD_BUTTON_LEFT_THUMB,
    GAMEPAD_BUTTON_RIGHT_THUMB
}


enum GamepadAxis -> i32 {
    GAMEPAD_AXIS_LEFT_X        = 0,
    GAMEPAD_AXIS_LEFT_Y        = 1,
    GAMEPAD_AXIS_RIGHT_X       = 2,
    GAMEPAD_AXIS_RIGHT_Y       = 3,
    GAMEPAD_AXIS_LEFT_TRIGGER  = 4,
    GAMEPAD_AXIS_RIGHT_TRIGGER = 5
}


enum MaterialMapIndex -> i32 {
    MATERIAL_MAP_ALBEDO = 0,
    MATERIAL_MAP_METALNESS,
    MATERIAL_MAP_NORMAL,
    MATERIAL_MAP_ROUGHNESS,
    MATERIAL_MAP_OCCLUSION,
    MATERIAL_MAP_EMISSION,
    MATERIAL_MAP_HEIGHT,
    MATERIAL_MAP_CUBEMAP,
    MATERIAL_MAP_IRRADIANCE,
    MATERIAL_MAP_PREFILTER,
    MATERIAL_MAP_BRDF
}

const MATERIAL_MAP_DIFFUSE: i32  = MATERIAL_MAP_ALBEDO;
const MATERIAL_MAP_SPECULAR: i32 = MATERIAL_MAP_METALNESS;

enum ShaderLocationIndex -> i32 {
    SHADER_LOC_VERTEX_POSITION = 0,
    SHADER_LOC_VERTEX_TEXCOORD01,
    SHADER_LOC_VERTEX_TEXCOORD02,
    SHADER_LOC_VERTEX_NORMAL,
    SHADER_LOC_VERTEX_TANGENT,
    SHADER_LOC_VERTEX_COLOR,
    SHADER_LOC_MATRIX_MVP,
    SHADER_LOC_MATRIX_VIEW,
    SHADER_LOC_MATRIX_PROJECTION,
    SHADER_LOC_MATRIX_MODEL,
    SHADER_LOC_MATRIX_NORMAL,
    SHADER_LOC_VECTOR_VIEW,
    SHADER_LOC_COLOR_DIFFUSE,
    SHADER_LOC_COLOR_SPECULAR,
    SHADER_LOC_COLOR_AMBIENT,
    SHADER_LOC_MAP_ALBEDO,
    SHADER_LOC_MAP_METALNESS,
    SHADER_LOC_MAP_NORMAL,
    SHADER_LOC_MAP_ROUGHNESS,
    SHADER_LOC_MAP_OCCLUSION,
    SHADER_LOC_MAP_EMISSION,
    SHADER_LOC_MAP_HEIGHT,
    SHADER_LOC_MAP_CUBEMAP,
    SHADER_LOC_MAP_IRRADIANCE,
    SHADER_LOC_MAP_PREFILTER,
    SHADER_LOC_MAP_BRDF,
    SHADER_LOC_VERTEX_BONEIDS,
    SHADER_LOC_VERTEX_BONEWEIGHTS,
    SHADER_LOC_BONE_MATRICES,
    SHADER_LOC_VERTEX_INSTANCE_TX
}

const SHADER_LOC_MAP_DIFFUSE: i32  = SHADER_LOC_MAP_ALBEDO;
const SHADER_LOC_MAP_SPECULAR: i32 = SHADER_LOC_MAP_METALNESS;

enum ShaderUniformDataType -> i32 {
    SHADER_UNIFORM_FLOAT = 0,
    SHADER_UNIFORM_VEC2,
    SHADER_UNIFORM_VEC3,
    SHADER_UNIFORM_VEC4,
    SHADER_UNIFORM_INT,
    SHADER_UNIFORM_IVEC2,
    SHADER_UNIFORM_IVEC3,
    SHADER_UNIFORM_IVEC4,
    SHADER_UNIFORM_UINT,
    SHADER_UNIFORM_UIVEC2,
    SHADER_UNIFORM_UIVEC3,
    SHADER_UNIFORM_UIVEC4,
    SHADER_UNIFORM_SAMPLER2D
}

enum ShaderAttributeDataType -> i32 {
    SHADER_ATTRIB_FLOAT = 0,
    SHADER_ATTRIB_VEC2,
    SHADER_ATTRIB_VEC3,
    SHADER_ATTRIB_VEC4
}

enum PixelFormat -> i32 {
    PIXELFORMAT_UNCOMPRESSED_GRAYSCALE = 1,
    PIXELFORMAT_UNCOMPRESSED_GRAY_ALPHA,
    PIXELFORMAT_UNCOMPRESSED_R5G6B5,
    PIXELFORMAT_UNCOMPRESSED_R8G8B8,
    PIXELFORMAT_UNCOMPRESSED_R5G5B5A1,
    PIXELFORMAT_UNCOMPRESSED_R4G4B4A4,
    PIXELFORMAT_UNCOMPRESSED_R8G8B8A8,
    PIXELFORMAT_UNCOMPRESSED_R32,
    PIXELFORMAT_UNCOMPRESSED_R32G32B32,
    PIXELFORMAT_UNCOMPRESSED_R32G32B32A32,
    PIXELFORMAT_UNCOMPRESSED_R16,
    PIXELFORMAT_UNCOMPRESSED_R16G16B16,
    PIXELFORMAT_UNCOMPRESSED_R16G16B16A16,
    PIXELFORMAT_COMPRESSED_DXT1_RGB,
    PIXELFORMAT_COMPRESSED_DXT1_RGBA,
    PIXELFORMAT_COMPRESSED_DXT3_RGBA,
    PIXELFORMAT_COMPRESSED_DXT5_RGBA,
    PIXELFORMAT_COMPRESSED_ETC1_RGB,
    PIXELFORMAT_COMPRESSED_ETC2_RGB,
    PIXELFORMAT_COMPRESSED_ETC2_EAC_RGBA,
    PIXELFORMAT_COMPRESSED_PVRT_RGB,
    PIXELFORMAT_COMPRESSED_PVRT_RGBA,
    PIXELFORMAT_COMPRESSED_ASTC_4x4_RGBA,
    PIXELFORMAT_COMPRESSED_ASTC_8x8_RGBA
}

enum TextureFilter -> i32 {
    TEXTURE_FILTER_POINT = 0,
    TEXTURE_FILTER_BILINEAR,
    TEXTURE_FILTER_TRILINEAR,
    TEXTURE_FILTER_ANISOTROPIC_4X,
    TEXTURE_FILTER_ANISOTROPIC_8X,
    TEXTURE_FILTER_ANISOTROPIC_16X,
}


 enum TextureWrap -> i32 {
    TEXTURE_WRAP_REPEAT = 0,
    TEXTURE_WRAP_CLAMP,
    TEXTURE_WRAP_MIRROR_REPEAT,
    TEXTURE_WRAP_MIRROR_CLAMP
}

enum CubemapLayout -> i32 {
    CUBEMAP_LAYOUT_AUTO_DETECT = 0,
    CUBEMAP_LAYOUT_LINE_VERTICAL,
    CUBEMAP_LAYOUT_LINE_HORIZONTAL,
    CUBEMAP_LAYOUT_CROSS_THREE_BY_FOUR,
    CUBEMAP_LAYOUT_CROSS_FOUR_BY_THREE
}


enum FontType -> i32 {
    FONT_DEFAULT = 0,
    FONT_BITMAP,
    FONT_SDF
}

enum BlendMode -> i32 {
    BLEND_ALPHA = 0,
    BLEND_ADDITIVE,
    BLEND_MULTIPLIED,
    BLEND_ADD_COLORS,
    BLEND_SUBTRACT_COLORS,
    BLEND_ALPHA_PREMULTIPLY,
    BLEND_CUSTOM,
    BLEND_CUSTOM_SEPARATE
}

enum Gesture -> i32 {
    GESTURE_NONE        = 0,
    GESTURE_TAP         = 1,
    GESTURE_DOUBLETAP   = 2,
    GESTURE_HOLD        = 4,
    GESTURE_DRAG        = 8,
    GESTURE_SWIPE_RIGHT = 16,
    GESTURE_SWIPE_LEFT  = 32,
    GESTURE_SWIPE_UP    = 64,
    GESTURE_SWIPE_DOWN  = 128,
    GESTURE_PINCH_IN    = 256,
    GESTURE_PINCH_OUT   = 512
}

enum CameraMode -> i32 {
    CAMERA_CUSTOM = 0,
    CAMERA_FREE,
    CAMERA_ORBITAL,
    CAMERA_FIRST_PERSON,
    CAMERA_THIRD_PERSON
}


enum CameraProjection -> i32 {
    CAMERA_PERSPECTIVE = 0,
    CAMERA_ORTHOGRAPHIC
}

enum NPatchLayout -> i32 {
    NPATCH_NINE_PATCH = 0,
    NPATCH_THREE_PATCH_VERTICAL,
    NPATCH_THREE_PATCH_HORIZONTAL
}

type TraceLogCallback = ptr<void>;
type LoadFileDataCallback = ptr<void>;
type SaveFileDataCallback = ptr<void>;
type LoadFileTextCallback = ptr<void>;
type SaveFileTextCallback = ptr<void>;
type AudioCallback = ptr<void>;

fun GetMouseRay(position: Vector2, camera: Camera) -> Ray {
    return GetScreenToWorldRay(position, camera);
}

extern(c) {
    fun InitWindow(width: i32, height: i32, title: ptr<u8>);
    fun CloseWindow();
    fun WindowShouldClose();
    fun IsWindowReady();
    fun IsWindowFullscreen();
    fun IsWindowHidden();
    fun IsWindowMinimized();
    fun IsWindowMaximized();
    fun IsWindowFocused();
    fun IsWindowResized();
    fun IsWindowState(flag: u32);
    fun SetWindowState(flags: u32);
    fun ClearWindowState(flags: u32);
    fun ToggleFullscreen();
    fun ToggleBorderlessWindowed();
    fun MaximizeWindow();
    fun MinimizeWindow();
    fun RestoreWindow();
    fun SetWindowIcon(image: Image);
    fun SetWindowIcons(images: ptr<Image>, count: i32);
    fun SetWindowTitle(title: ptr<i8>);
    fun SetWindowPosition(x: i32, y: i32);
    fun SetWindowMonitor(monitor: i32);
    fun SetWindowMinSize(width: i32, height: i32);
    fun SetWindowMaxSize(width: i32, height: i32);
    fun SetWindowSize(width: i32, height: i32);
    fun SetWindowOpacity(opacity: f32);
    fun SetWindowFocused();
    fun GetWindowHandle() -> ptr<void>;
    fun GetScreenWidth();
    fun GetScreenHeight();
    fun GetRenderWidth();
    fun GetRenderHeight();
    fun GetMonitorCount();
    fun GetCurrentMonitor();
    fun GetMonitorPosition(monitor: i32) -> Vector2;
    fun GetMonitorWidth(monitor: i32);
    fun GetMonitorHeight(monitor: i32);
    fun GetMonitorPhysicalWidth(monitor: i32);
    fun GetMonitorPhysicalHeight(monitor: i32);
    fun GetMonitorRefreshRate(monitor: i32);
    fun GetWindowPosition() -> Vector2;
    fun GetWindowScaleDPI() -> Vector2;
    fun GetMonitorName(monitor: i32) -> ptr<i8>;
    fun SetClipboardText(text: ptr<i8>);
    fun GetClipboardText() -> ptr<i8>;
    fun GetClipboardImage() -> Image;
    fun EnableEventWaiting();
    fun DisableEventWaiting();
    fun ShowCursor();
    fun HideCursor();
    fun IsCursorHidden() -> bool;
    fun EnableCursor();
    fun DisableCursor();
    fun IsCursorOnScreen() -> bool;
    fun ClearBackground(color: Color);
    fun BeginDrawing();
    fun EndDrawing();
    fun BeginMode2D(camera: Camera2D);
    fun EndMode2D();
    fun BeginMode3D(camera: Camera3D);
    fun EndMode3D();
    fun BeginTextureMode(target: RenderTexture2D);
    fun EndTextureMode();
    fun BeginShaderMode(shader: Shader);
    fun EndShaderMode();
    fun BeginBlendMode(mode: i32);
    fun EndBlendMode();
    fun BeginScissorMode(x: i32, y: i32, width: i32, height: i32);
    fun EndScissorMode();
    fun BeginVrStereoMode(config: VrStereoConfig);
    fun EndVrStereoMode();
    fun LoadVrStereoConfig(device: VrDeviceInfo) -> VrStereoConfig;
    fun UnloadVrStereoConfig(config: VrStereoConfig);
    fun LoadShader(vsFileName: ptr<i8>, fsFileName: ptr<i8>) -> Shader;
    fun LoadShaderFromMemory(vsCode: ptr<i8>, fsCode: ptr<i8>) -> Shader;
    fun IsShaderValid(shader: Shader) -> bool;
    fun GetShaderLocation(shader: Shader, uniformName: ptr<i8>) -> i32;
    fun GetShaderLocationAttrib(shader: Shader, attribName: ptr<i8>) -> i32;
    fun SetShaderValue(shader: Shader, locIndex: i32, value: ptr<u8>, uniformType: i32);
    fun SetShaderValueV(shader: Shader, locIndex: i32, value: ptr<u8>, uniformType: i32, count: i32);
    fun SetShaderValueMatrix(shader: Shader, locIndex: i32, mat: Matrix);
    fun SetShaderValueTexture(shader: Shader, locIndex: i32, texture: Texture2D);
    fun UnloadShader(shader: Shader);
    fun GetScreenToWorldRay(position: Vector2, camera: Camera) -> Ray;
    fun GetScreenToWorldRayEx(position: Vector2, camera: Camera, width: i32, height: i32) -> Ray;
    fun GetWorldToScreen(position: Vector3, camera: Camera) -> Vector2;
    fun GetWorldToScreenEx(position: Vector3, camera: Camera, width: i32, height: i32) -> Vector2;
    fun GetWorldToScreen2D(position: Vector2, camera: Camera2D) -> Vector2;
    fun GetScreenToWorld2D(position: Vector2, camera: Camera2D) -> Vector2;
    fun GetCameraMatrix(camera: Camera) -> Matrix;
    fun GetCameraMatrix2D(camera: Camera2D) -> Matrix;
    fun SetTargetFPS(fps: i32);
    fun GetFrameTime() -> f32;
    fun GetTime() -> f64;
    fun GetFPS() -> i32;
    fun SwapScreenBuffer();
    fun PollInputEvents();
    fun WaitTime(seconds: f64);
    fun SetRandomSeed(seed: u32);
    fun GetRandomValue(min: i32, max: i32) -> i32;
    fun LoadRandomSequence(count: u32, min: i32, max: i32) -> ptr<i32>;
    fun UnloadRandomSequence(sequence: ptr<i32>);
    fun TakeScreenshot(fileName: ptr<i8>);
    fun SetConfigFlags(flags: u32);
    fun OpenURL(url: ptr<i8>);
    fun SetTraceLogLevel(logLevel: i32);
    fun TraceLog(logLevel: i32, text: ptr<i8>);
    fun SetTraceLogCallback(callback: TraceLogCallback);
    fun MemAlloc(size: u32) -> ptr<u8>;
    fun MemRealloc(ptr: ptr<u8>, size: u32) -> ptr<u8>;
    fun MemFree(ptr: ptr<u8>);
    fun LoadFileData(fileName: ptr<i8>, dataSize: ptr<i32>) -> ptr<i8>;
    fun UnloadFileData(data: ptr<i8>);
    fun SaveFileData(fileName: ptr<i8>, data: ptr<u8>, dataSize: i32) -> bool;
    fun ExportDataAsCode(data: ptr<u8>, dataSize: i32, fileName: ptr<i8>) -> bool;
    fun LoadFileText(fileName: ptr<i8>) -> ptr<i8>;
    fun UnloadFileText(text: ptr<i8>);
    fun SaveFileText(fileName: ptr<i8>, text: ptr<i8>) -> bool;
    fun SetLoadFileDataCallback(callback: LoadFileDataCallback);
    fun SetSaveFileDataCallback(callback: SaveFileDataCallback);
    fun SetLoadFileTextCallback(callback: LoadFileTextCallback);
    fun SetSaveFileTextCallback(callback: SaveFileTextCallback);
    fun FileRename(fileName: ptr<i8>, fileRename: ptr<i8>) -> i32;
    fun FileRemove(fileName: ptr<i8>) -> i32;
    fun FileCopy(srcPath: ptr<i8>, dstPath: ptr<i8>) -> i32;
    fun FileMove(srcPath: ptr<i8>, dstPath: ptr<i8>) -> i32;
    fun FileTextReplace(fileName: ptr<i8>, search: ptr<i8>, replacement: ptr<i8>) -> i32;
    fun FileTextFindIndex(fileName: ptr<i8>, search: ptr<i8>) -> i32;
    fun FileExists(fileName: ptr<i8>) -> bool;
    fun DirectoryExists(dirPath: ptr<i8>) -> bool;
    fun IsFileExtension(fileName: ptr<i8>, ext: ptr<i8>) -> bool;
    fun GetFileLength(fileName: ptr<i8>) -> i32;
    fun GetFileModTime(fileName: ptr<i8>) -> i64;
    fun GetFileExtension(fileName: ptr<i8>) -> ptr<i8>;
    fun GetFileName(filePath: ptr<i8>) -> ptr<i8>;
    fun GetFileNameWithoutExt(filePath: ptr<i8>) -> ptr<i8>;
    fun GetDirectoryPath(filePath: ptr<i8>) -> ptr<i8>;
    fun GetPrevDirectoryPath(dirPath: ptr<i8>) -> ptr<i8>;
    fun GetWorkingDirectory() -> ptr<i8>;
    fun GetApplicationDirectory() -> ptr<i8>;
    fun MakeDirectory(dirPath: ptr<i8>) -> i32;
    fun ChangeDirectory(dirPath: ptr<i8>) -> bool;
    fun IsPathFile(path: ptr<i8>) -> bool;
    fun IsFileNameValid(fileName: ptr<i8>) -> bool;
    fun LoadDirectoryFiles(dirPath: ptr<i8>) -> FilePathList;
    fun LoadDirectoryFilesEx(basePath: ptr<i8>, filter: ptr<i8>, scanSubdirs: bool) -> FilePathList;
    fun UnloadDirectoryFiles(files: FilePathList);
    fun IsFileDropped() -> bool;
    fun LoadDroppedFiles() -> FilePathList;
    fun UnloadDroppedFiles(files: FilePathList);
    fun GetDirectoryFileCount(dirPath: ptr<i8>) -> u32;
    fun GetDirectoryFileCountEx(basePath: ptr<i8>, filter: ptr<i8>, scanSubdirs: bool) -> u32;
    fun CompressData(data: ptr<u8>, dataSize: i32, compDataSize: ptr<i32>) -> ptr<u8>;
    fun DecompressData(compData: ptr<u8>, compDataSize: i32, dataSize: ptr<i32>) -> ptr<u8>;
    fun EncodeDataBase64(data: ptr<u8>, dataSize: i32, outputSize: ptr<i32>) -> ptr<i8>;
    fun DecodeDataBase64(text: ptr<i8>, outputSize: ptr<i32>) -> ptr<u8>;
    fun ComputeCRC32(data: ptr<u8>, dataSize: i32) -> u32;
    fun ComputeMD5(data: ptr<u8>, dataSize: i32) -> ptr<u8>;
    fun ComputeSHA1(data: ptr<u8>, dataSize: i32) -> ptr<u8>;
    fun ComputeSHA256(data: ptr<u8>, dataSize: i32) -> ptr<u8>;
    fun LoadAutomationEventList(fileName: ptr<i8>) -> AutomationEventList;
    fun UnloadAutomationEventList(list: AutomationEventList);
    fun ExportAutomationEventList(list: AutomationEventList, fileName: ptr<i8>) -> bool;
    fun SetAutomationEventList(list: ptr<AutomationEventList>);
    fun SetAutomationEventBaseFrame(frame: i32);
    fun StartAutomationEventRecording();
    fun StopAutomationEventRecording();
    fun PlayAutomationEvent(event: AutomationEvent);
    fun IsKeyPressed(key: i32) -> bool;
    fun IsKeyPressedRepeat(key: i32) -> bool;
    fun IsKeyDown(key: i32) -> bool;
    fun IsKeyReleased(key: i32) -> bool;
    fun IsKeyUp(key: i32) -> bool;
    fun GetKeyPressed() -> i32;
    fun GetCharPressed() -> i32;
    fun GetKeyName(key: i32) -> ptr<i8>;
    fun SetExitKey(key: i32);
    fun IsGamepadAvailable(gamepad: i32) -> bool;
    fun GetGamepadName(gamepad: i32) -> ptr<i8>;
    fun IsGamepadButtonPressed(gamepad: i32, button: i32) -> bool;
    fun IsGamepadButtonDown(gamepad: i32, button: i32) -> bool;
    fun IsGamepadButtonReleased(gamepad: i32, button: i32) -> bool;
    fun IsGamepadButtonUp(gamepad: i32, button: i32) -> bool;
    fun GetGamepadButtonPressed() -> i32;
    fun GetGamepadAxisCount(gamepad: i32) -> i32;
    fun GetGamepadAxisMovement(gamepad: i32, axis: i32) -> f32;
    fun SetGamepadMappings(mappings: ptr<i8>) -> i32;
    fun SetGamepadVibration(gamepad: i32, leftMotor: f32, rightMotor: f32, duration: f32);
    fun IsMouseButtonPressed(button: i32) -> bool;
    fun IsMouseButtonDown(button: i32) -> bool;
    fun IsMouseButtonReleased(button: i32) -> bool;
    fun IsMouseButtonUp(button: i32) -> bool;
    fun GetMouseX() -> i32;
    fun GetMouseY() -> i32;
    fun GetMousePosition() -> Vector2;
    fun GetMouseDelta() -> Vector2;
    fun SetMousePosition(x: i32, y: i32);
    fun SetMouseOffset(offsetX: i32, offsetY: i32);
    fun SetMouseScale(scaleX: f32, scaleY: f32);
    fun GetMouseWheelMove() -> f32;
    fun GetMouseWheelMoveV() -> Vector2;
    fun SetMouseCursor(cursor: i32);
    fun GetTouchX() -> i32;
    fun GetTouchY() -> i32;
    fun GetTouchPosition(index: i32) -> Vector2;
    fun GetTouchPointId(index: i32) -> i32;
    fun GetTouchPointCount() -> i32;
    fun SetGesturesEnabled(flags: u32);
    fun IsGestureDetected(gesture: u32) -> bool;
    fun GetGestureDetected() -> i32;
    fun GetGestureHoldDuration() -> f32;
    fun GetGestureDragVector() -> Vector2;
    fun GetGestureDragAngle() -> f32;
    fun GetGesturePinchVector() -> Vector2;
    fun GetGesturePinchAngle() -> f32;
    fun UpdateCamera(camera: ptr<Camera>, mode: i32);
    fun UpdateCameraPro(camera: ptr<Camera>, movement: Vector3, rotation: Vector3, zoom: f32);
    fun SetShapesTexture(texture: Texture2D, source: Rectangle);
    fun GetShapesTexture() -> Texture2D;
    fun GetShapesTextureRectangle() -> Rectangle;
    fun DrawPixel(posX: i32, posY: i32, color: Color);
    fun DrawPixelV(position: Vector2, color: Color);
    fun DrawLine(startPosX: i32, startPosY: i32, endPosX: i32, endPosY: i32, color: Color);
    fun DrawLineV(startPos: Vector2, endPos: Vector2, color: Color);
    fun DrawLineEx(startPos: Vector2, endPos: Vector2, thick: i32, color: Color);
    fun DrawLineStrip(points: ptr<Vector2>, pointCount: i32, color: Color);
    fun DrawLineBezier(startPos: Vector2, endPos: Vector2, thick: f32, color: Color);
    fun DrawLineDashed(startPos: Vector2, endPos: Vector2, dashSize: i32, spaceSize: i32, color: Color);
    fun DrawCircle(centerX: i32, centerY: i32, radius: f32, color: Color);
    fun DrawCircleSector(center: Vector2, radius: f32, startAngle: f32, endAngle: f32, segments: i32, color: Color);
    fun DrawCircleSectorLines(center: Vector2, radius: f32, startAngle: f32, endAngle: f32, segments: i32, color: Color);
    fun DrawCircleGradient(centerX: i32, centerY: i32, radius: f32, inner: Color, outer: Color);
    fun DrawCircleV(center: Vector2, radius: f32, color: Color);
    fun DrawCircleLines(centerX: i32, centerY: i32, radius: f32, color: Color);
    fun DrawCircleLinesV(center: Vector2, radius: f32, color: Color);
    fun DrawEllipse(centerX: i32, centerY: i32, radiusH: f32, radiusV: f32, color: Color);
    fun DrawEllipseV(center: Vector2, radiusH: f32, radiusV: f32, color: Color);
    fun DrawEllipseLines(centerX: i32, centerY: i32, radiusH: f32, radiusV: f32, color: Color);
    fun DrawEllipseLinesV(center: Vector2, radiusH: f32, radiusV: f32, color: Color);
    fun DrawRing(center: Vector2, innerRadius: f32, outerRadius: f32, startAngle: f32, endAngle: f32, segments: i32, color: Color);
    fun DrawRingLines(center: Vector2, innerRadius: i32, outerRadius: f32, startAngle: f32, endAngle: f32, segments: i32, color: Color);
    fun DrawRectangle(posX: i32, posY: i32, width: i32, height: i32, color: Color);
    fun DrawRectangleV(position: Vector2, size: Vector2, color: Color);
    fun DrawRectangleRec(rec: Rectangle, color: Color);
    fun DrawRectanglePro(rec: Rectangle, origin: Vector2, rotation: i32, color: Color);
    fun DrawRectangleGradientV(posX: i32, posY: i32, width: i32, height: i32, top: Color, bottom: Color);
    fun DrawRectangleGradientH(posX: i32, posY: i32, width: i32, height: i32, left: Color, right: Color);
    fun DrawRectangleGradientEx(rec: Rectangle, topLeft: Color, bottomLeft: Color, bottomRight: Color, topRight: Color);
    fun DrawRectangleLines(posX: i32, posY: i32, width: i32, height: i32, color: Color);
    fun DrawRectangleLinesEx(rec: Rectangle, lineThick: i32, color: Color);
    fun DrawRectangleRounded(rec: Rectangle, roundness: i32, segments: i32, color: Color);
    fun DrawRectangleRoundedLines(rec: Rectangle, roundness: i32, segments: i32, color: Color);
    fun DrawRectangleRoundedLinesEx(rec: Rectangle, roundness: i32, segments: i32, lineThick: i32, color: Color);
    fun DrawTriangle(v1: Vector2, v2: Vector2, v3: Vector2, color: Color);
    fun DrawTriangleLines(v1: Vector2, v2: Vector2, v3: Vector2, color: Color);
    fun DrawTriangleFan(points: ptr<Vector2>, pointCount: i32, color: Color);
    fun DrawTriangleStrip(points: ptr<Vector2>, pointCount: i32, color: Color);
    fun DrawPoly(center: Vector2, sides: i32, radius: i32, rotation: i32, color: Color);
    fun DrawPolyLines(center: Vector2, sides: i32, radius: i32, rotation: i32, color: Color);
    fun DrawPolyLinesEx(center: Vector2, sides: i32, radius: i32, rotation: i32, lineThick: i32, color: Color);
    fun DrawSplineLinear(points: ptr<Vector2>, pointCount: i32, thick: i32, color: Color);
    fun DrawSplineBasis(points: ptr<Vector2>, pointCount: i32, thick: i32, color: Color);
    fun DrawSplineCatmullRom(points: ptr<Vector2>, pointCount: i32, thick: i32, color: Color);
    fun DrawSplineBezierQuadratic(points: ptr<Vector2>, pointCount: i32, thick: i32, color: Color);
    fun DrawSplineBezierCubic(points: ptr<Vector2>, pointCount: i32, thick: i32, color: Color);
    fun DrawSplineSegmentLinear(p1: Vector2, p2: Vector2, thick: i32, color: Color);
    fun DrawSplineSegmentBasis(p1: Vector2, p2: Vector2, p3: Vector2, p4: Vector2, thick: i32, color: Color);
    fun DrawSplineSegmentCatmullRom(p1: Vector2, p2: Vector2, p3: Vector2, p4: Vector2, thick: i32, color: Color);
    fun DrawSplineSegmentBezierQuadratic(p1: Vector2, c2: Vector2, p3: Vector2, thick: i32, color: Color);
    fun DrawSplineSegmentBezierCubic(p1: Vector2, c2: Vector2, c3: Vector2, p4: Vector2, thick: i32, color: Color);
    fun GetSplinePointLinear(startPos: Vector2, endPos: Vector2, t: i32) -> Vector2;
    fun GetSplinePointBasis(p1: Vector2, p2: Vector2, p3: Vector2, p4: Vector2, t: i32) -> Vector2;
    fun GetSplinePointCatmullRom(p1: Vector2, p2: Vector2, p3: Vector2, p4: Vector2, t: i32) -> Vector2;
    fun GetSplinePointBezierQuad(p1: Vector2, c2: Vector2, p3: Vector2, t: i32) -> Vector2;
    fun GetSplinePointBezierCubic(p1: Vector2, c2: Vector2, c3: Vector2, p4: Vector2, t: i32) -> Vector2;
    fun CheckCollisionRecs(rec1: Rectangle, rec2: Rectangle) -> bool;
    fun CheckCollisionCircles(center1: Vector2, radius1: i32, center2: Vector2, radius2: i32) -> bool;
    fun CheckCollisionCircleRec(center: Vector2, radius: i32, rec: Rectangle) -> bool;
    fun CheckCollisionCircleLine(center: Vector2, radius: i32, p1: Vector2, p2: Vector2) -> bool;
    fun CheckCollisionPointRec(point: Vector2, rec: Rectangle) -> bool;
    fun CheckCollisionPointCircle(point: Vector2, center: Vector2, radius: i32) -> bool;
    fun CheckCollisionPointTriangle(point: Vector2, p1: Vector2, p2: Vector2, p3: Vector2) -> bool;
    fun CheckCollisionPointLine(point: Vector2, p1: Vector2, p2: Vector2, threshold: i32) -> bool;
    fun CheckCollisionPointPoly(point: Vector2, points: ptr<Vector2>, pointCount: i32) -> bool;
    fun CheckCollisionLines(startPos1: Vector2, endPos1: Vector2, startPos2: Vector2, endPos2: Vector2, collisionPoint: ptr<Vector2>) -> bool;
    fun GetCollisionRec(rec1: Rectangle, rec2: Rectangle) -> Rectangle;
    fun LoadImage(fileName: ptr<i8>) -> Image;
    fun LoadImageRaw(fileName: ptr<i8>, width: i32, height: i32, format: i32, headerSize: i32) -> Image;
    fun LoadImageAnim(fileName: ptr<i8>, frames: ptr<i32>) -> Image;
    fun LoadImageAnimFromMemory(fileType: ptr<i8>, fileData: ptr<u8>, dataSize: i32, frames: ptr<i32>) -> Image;
    fun LoadImageFromMemory(fileType: ptr<i8>, fileData: ptr<u8>, dataSize: i32) -> Image;
    fun LoadImageFromTexture(texture: Texture2D) -> Image;
    fun LoadImageFromScreen() -> Image;
    fun IsImageValid(image: Image) -> bool;
    fun UnloadImage(image: Image);
    fun ExportImage(image: Image, fileName: ptr<i8>) -> bool;
    fun ExportImageToMemory(image: Image, fileType: ptr<i8>, fileSize: ptr<i32>) -> ptr<u8>;
    fun ExportImageAsCode(image: Image, fileName: ptr<i8>) -> bool;
    fun GenImageColor(width: i32, height: i32, color: Color) -> Image;
    fun GenImageGradientLinear(width: i32, height: i32, direction: i32, start: Color, end: Color) -> Image;
    fun GenImageGradientRadial(width: i32, height: i32, density: i32, inner: Color, outer: Color) -> Image;
    fun GenImageGradientSquare(width: i32, height: i32, density: i32, inner: Color, outer: Color) -> Image;
    fun GenImageChecked(width: i32, height: i32, checksX: i32, checksY: i32, col1: Color, col2: Color) -> Image;
    fun GenImageWhiteNoise(width: i32, height: i32, factor: i32) -> Image;
    fun GenImagePerlinNoise(width: i32, height: i32, offsetX: i32, offsetY: i32, scale: i32) -> Image;
    fun GenImageCellular(width: i32, height: i32, tileSize: i32) -> Image;
    fun GenImageText(width: i32, height: i32, text: ptr<i8>) -> Image;
    fun ImageCopy(image: Image) -> Image;
    fun ImageFromImage(image: Image, rec: Rectangle) -> Image;
    fun ImageFromChannel(image: Image, selectedChannel: i32) -> Image;
    fun ImageText(text: ptr<i8>, fontSize: i32, color: Color) -> Image;
    fun ImageTextEx(font: Font, text: ptr<i8>, fontSize: i32, spacing: i32, tint: Color) -> Image;
    fun ImageFormat(image: ptr<Image>, newFormat: i32);
    fun ImageToPOT(image: ptr<Image>, fill: Color);
    fun ImageCrop(image: ptr<Image>, crop: Rectangle);
    fun ImageAlphaCrop(image: ptr<Image>, threshold: i32);
    fun ImageAlphaClear(image: ptr<Image>, color: Color, threshold: i32);
    fun ImageAlphaMask(image: ptr<Image>, alphaMask: Image);
    fun ImageAlphaPremultiply(image: ptr<Image>);
    fun ImageBlurGaussian(image: ptr<Image>, blurSize: i32);
    fun ImageKernelConvolution(image: ptr<Image>, kernel: ptr<i32>, kernelSize: i32);
    fun ImageResize(image: ptr<Image>, newWidth: i32, newHeight: i32);
    fun ImageResizeNN(image: ptr<Image>, newWidth: i32, newHeight: i32);
    fun ImageResizeCanvas(image: ptr<Image>, newWidth: i32, newHeight: i32, offsetX: i32, offsetY: i32, fill: Color);
    fun ImageMipmaps(image: ptr<Image>);
    fun ImageDither(image: ptr<Image>, rBpp: i32, gBpp: i32, bBpp: i32, aBpp: i32);
    fun ImageFlipVertical(image: ptr<Image>);
    fun ImageFlipHorizontal(image: ptr<Image>);
    fun ImageRotate(image: ptr<Image>, degrees: i32);
    fun ImageRotateCW(image: ptr<Image>);
    fun ImageRotateCCW(image: ptr<Image>);
    fun ImageColorTint(image: ptr<Image>, color: Color);
    fun ImageColorInvert(image: ptr<Image>);
    fun ImageColorGrayscale(image: ptr<Image>);
    fun ImageColorContrast(image: ptr<Image>, contrast: i32);
    fun ImageColorBrightness(image: ptr<Image>, brightness: i32);
    fun ImageColorReplace(image: ptr<Image>, color: Color, replace: Color);
    fun LoadImageColors(image: Image) -> ptr<Color>;
    fun LoadImagePalette(image: Image, maxPaletteSize: i32, colorCount: ptr<i32>) -> ptr<Color>;
    fun UnloadImageColors(colors: ptr<Color>);
    fun UnloadImagePalette(colors: ptr<Color>);
    fun GetImageAlphaBorder(image: Image, threshold: i32) -> Rectangle;
    fun GetImageColor(image: Image, x: i32, y: i32) -> Color;
    fun ImageClearBackground(dst: ptr<Image>, color: Color);
    fun ImageDrawPixel(dst: ptr<Image>, posX: i32, posY: i32, color: Color);
    fun ImageDrawPixelV(dst: ptr<Image>, position: Vector2, color: Color);
    fun ImageDrawLine(dst: ptr<Image>, startPosX: i32, startPosY: i32, endPosX: i32, endPosY: i32, color: Color);
    fun ImageDrawLineV(dst: ptr<Image>, start: Vector2, end: Vector2, color: Color);
    fun ImageDrawLineEx(dst: ptr<Image>, start: Vector2, end: Vector2, thick: i32, color: Color);
    fun ImageDrawCircle(dst: ptr<Image>, centerX: i32, centerY: i32, radius: i32, color: Color);
    fun ImageDrawCircleV(dst: ptr<Image>, center: Vector2, radius: i32, color: Color);
    fun ImageDrawCircleLines(dst: ptr<Image>, centerX: i32, centerY: i32, radius: i32, color: Color);
    fun ImageDrawCircleLinesV(dst: ptr<Image>, center: Vector2, radius: i32, color: Color);
    fun ImageDrawRectangle(dst: ptr<Image>, posX: i32, posY: i32, width: i32, height: i32, color: Color);
    fun ImageDrawRectangleV(dst: ptr<Image>, position: Vector2, size: Vector2, color: Color);
    fun ImageDrawRectangleRec(dst: ptr<Image>, rec: Rectangle, color: Color);
    fun ImageDrawRectangleLines(dst: ptr<Image>, rec: Rectangle, thick: i32, color: Color);
    fun ImageDrawTriangle(dst: ptr<Image>, v1: Vector2, v2: Vector2, v3: Vector2, color: Color);
    fun ImageDrawTriangleEx(dst: ptr<Image>, v1: Vector2, v2: Vector2, v3: Vector2, c1: Color, c2: Color, c3: Color);
    fun ImageDrawTriangleLines(dst: ptr<Image>, v1: Vector2, v2: Vector2, v3: Vector2, color: Color);
    fun ImageDrawTriangleFan(dst: ptr<Image>, points: ptr<Vector2>, pointCount: i32, color: Color);
    fun ImageDrawTriangleStrip(dst: ptr<Image>, points: ptr<Vector2>, pointCount: i32, color: Color);
    fun ImageDraw(dst: ptr<Image>, src: Image, srcRec: Rectangle, dstRec: Rectangle, tint: Color);
    fun ImageDrawText(dst: ptr<Image>, text: ptr<i8>, posX: i32, posY: i32, fontSize: i32, color: Color);
    fun ImageDrawTextEx(dst: ptr<Image>, font: Font, text: ptr<i8>, position: Vector2, fontSize: i32, spacing: i32, tint: Color);
    fun LoadTexture(fileName: ptr<i8>) -> Texture2D;
    fun LoadTextureFromImage(image: Image) -> Texture2D;
    fun LoadTextureCubemap(image: Image, layout: i32) -> TextureCubemap;
    fun LoadRenderTexture(width: i32, height: i32) -> RenderTexture2D;
    fun IsTextureValid(texture: Texture2D) -> bool;
    fun UnloadTexture(texture: Texture2D);
    fun IsRenderTextureValid(target: RenderTexture2D) -> bool;
    fun UnloadRenderTexture(target: RenderTexture2D);
    fun UpdateTexture(texture: Texture2D, pixels: ptr<u8>);
    fun UpdateTextureRec(texture: Texture2D, rec: Rectangle, pixels: ptr<u8>);
    fun GenTextureMipmaps(texture: ptr<Texture2D>);
    fun SetTextureFilter(texture: Texture2D, filter: i32);
    fun SetTextureWrap(texture: Texture2D, wrap: i32);
    fun DrawTexture(texture: Texture2D, posX: i32, posY: i32, tint: Color);
    fun DrawTextureV(texture: Texture2D, position: Vector2, tint: Color);
    fun DrawTextureEx(texture: Texture2D, position: Vector2, rotation: i32, scale: i32, tint: Color);
    fun DrawTextureRec(texture: Texture2D, source: Rectangle, position: Vector2, tint: Color);
    fun DrawTexturePro(texture: Texture2D, source: Rectangle, dest: Rectangle, origin: Vector2, rotation: i32, tint: Color);
    fun DrawTextureNPatch(texture: Texture2D, nPatchInfo: NPatchInfo, dest: Rectangle, origin: Vector2, rotation: i32, tint: Color);
    fun ColorIsEqual(col1: Color, col2: Color) -> bool;
    fun Fade(color: Color, alpha: i32) -> Color;
    fun ColorToInt(color: Color) -> i32;
    fun ColorNormalize(color: Color) -> Vector4;
    fun ColorFromNormalized(normalized: Vector4) -> Color;
    fun ColorToHSV(color: Color) -> Vector3;
    fun ColorFromHSV(hue: i32, saturation: i32, value: i32) -> Color;
    fun ColorTint(color: Color, tint: Color) -> Color;
    fun ColorBrightness(color: Color, factor: i32) -> Color;
    fun ColorContrast(color: Color, contrast: i32) -> Color;
    fun ColorAlpha(color: Color, alpha: i32) -> Color;
    fun ColorAlphaBlend(dst: Color, src: Color, tint: Color) -> Color;
    fun ColorLerp(color1: Color, color2: Color, factor: i32) -> Color;
    fun GetColor(hexValue: u32) -> Color;
    fun GetPixelColor(srcPtr: ptr<u8>, format: i32) -> Color;
    fun SetPixelColor(dstPtr: ptr<u8>, color: Color, format: i32);
    fun GetPixelDataSize(width: i32, height: i32, format: i32) -> i32;
    fun GetFontDefault() -> Font;
    fun LoadFont(fileName: ptr<i8>) -> Font;
    fun LoadFontEx(fileName: ptr<i8>, fontSize: i32, codepoints: ptr<i32>, codepointCount: i32) -> Font;
    fun LoadFontFromImage(image: Image, key: Color, firstChar: i32) -> Font;
    fun LoadFontFromMemory(fileType: ptr<i8>, fileData: ptr<u8>, dataSize: i32, fontSize: i32, codepoints: ptr<i32>, codepointCount: i32) -> Font;
    fun IsFontValid(font: Font) -> bool;
    fun LoadFontData(fileData: ptr<u8>, dataSize: i32, fontSize: i32, codepoints: ptr<i32>, codepointCount: i32, dataType: i32, glyphCount: ptr<i32>) -> ptr<GlyphInfo>;
    fun GenImageFontAtlas(glyphs: ptr<GlyphInfo>, glyphRecs: ptr<ptr<Rectangle>>, glyphCount: i32, fontSize: i32, padding: i32, packMethod: i32) -> Image;
    fun UnloadFontData(glyphs: ptr<GlyphInfo>, glyphCount: i32);
    fun UnloadFont(font: Font);
    fun ExportFontAsCode(font: Font, fileName: ptr<i8>) -> bool;
    fun DrawFPS(posX: i32, posY: i32);
    fun DrawText(text: ptr<i8>, posX: i32, posY: i32, fontSize: i32, color: Color);
    fun DrawTextEx(font: Font, text: ptr<i8>, position: Vector2, fontSize: i32, spacing: i32, tint: Color);
    fun DrawTextPro(font: Font, text: ptr<i8>, position: Vector2, origin: Vector2, rotation: i32, fontSize: i32, spacing: i32, tint: Color);
    fun DrawTextCodepoint(font: Font, codepoint: i32, position: Vector2, fontSize: i32, tint: Color);
    fun DrawTextCodepoints(font: Font, codepoints: ptr<i32>, codepointCount: i32, position: Vector2, fontSize: i32, spacing: i32, tint: Color);
    fun SetTextLineSpacing(spacing: i32);
    fun MeasureText(text: ptr<i8>, fontSize: i32) -> i32;
    fun MeasureTextEx(font: Font, text: ptr<i8>, fontSize: i32, spacing: i32) -> Vector2;
    fun GetGlyphIndex(font: Font, codepoint: i32) -> i32;
    fun GetGlyphInfo(font: Font, codepoint: i32) -> GlyphInfo;
    fun GetGlyphAtlasRec(font: Font, codepoint: i32) -> Rectangle;
    fun LoadUTF8(codepoints: ptr<i32>, length: i32) -> ptr<i8>;
    fun UnloadUTF8(text: ptr<i8>);
    fun LoadCodepoints(text: ptr<i8>, count: ptr<i32>) -> ptr<i32>;
    fun UnloadCodepoints(codepoints: ptr<i32>);
    fun GetCodepointCount(text: ptr<i8>) -> i32;
    fun GetCodepoint(text: ptr<i8>, codepointSize: ptr<i32>) -> i32;
    fun GetCodepointNext(text: ptr<i8>, codepointSize: ptr<i32>) -> i32;
    fun GetCodepointPrevious(text: ptr<i8>, codepointSize: ptr<i32>) -> i32;
    fun CodepointToUTF8(codepoint: i32, utf8Size: ptr<i32>) -> ptr<i8>;
    fun LoadTextLines(text: ptr<i8>, count: ptr<i32>) -> ptr<ptr<i8>>;
    fun UnloadTextLines(text: ptr<ptr<i8>>, lineCount: i32);
    fun TextCopy(dst: ptr<i8>, src: ptr<i8>) -> i32;
    fun TextIsEqual(text1: ptr<i8>, text2: ptr<i8>) -> bool;
    fun TextLength(text: ptr<i8>) -> u32;
    fun TextSubtext(text: ptr<i8>, position: i32, length: i32) -> ptr<i8>;
    fun TextRemoveSpaces(text: ptr<i8>) -> ptr<i8>;
    fun GetTextBetween(text: ptr<i8>, begin: ptr<i8>, end: ptr<i8>) -> ptr<i8>;
    fun TextReplace(text: ptr<i8>, search: ptr<i8>, replacement: ptr<i8>) -> ptr<i8>;
    fun TextReplaceBetween(text: ptr<i8>, begin: ptr<i8>, end: ptr<i8>, replacement: ptr<i8>) -> ptr<i8>;
    fun TextInsert(text: ptr<i8>, insert: ptr<i8>, position: i32) -> ptr<i8>;
    fun TextJoin(textList: ptr<ptr<i8>>, count: i32, delimiter: ptr<i8>) -> ptr<i8>;
    fun TextSplit(text: ptr<i8>, delimiter: i8, count: ptr<i32>) -> ptr<ptr<i8>>;
    fun TextAppend(text: ptr<i8>, append: ptr<i8>, position: ptr<i32>);
    fun TextFindIndex(text: ptr<i8>, search: ptr<i8>) -> i32;
    fun TextToUpper(text: ptr<i8>) -> ptr<i8>;
    fun TextToLower(text: ptr<i8>) -> ptr<i8>;
    fun TextToPascal(text: ptr<i8>) -> ptr<i8>;
    fun TextToSnake(text: ptr<i8>) -> ptr<i8>;
    fun TextToCamel(text: ptr<i8>) -> ptr<i8>;
    fun TextToInteger(text: ptr<i8>) -> i32;
    fun TextToFloat(text: ptr<i8>) -> i32;
    fun DrawLine3D(startPos: Vector3, endPos: Vector3, color: Color);
    fun DrawPoint3D(position: Vector3, color: Color);
    fun DrawCircle3D(center: Vector3, radius: i32, rotationAxis: Vector3, rotationAngle: i32, color: Color);
    fun DrawTriangle3D(v1: Vector3, v2: Vector3, v3: Vector3, color: Color);
    fun DrawTriangleStrip3D(points: ptr<Vector3>, pointCount: i32, color: Color);
    fun DrawCube(position: Vector3, width: i32, height: i32, length: i32, color: Color);
    fun DrawCubeV(position: Vector3, size: Vector3, color: Color);
    fun DrawCubeWires(position: Vector3, width: i32, height: i32, length: i32, color: Color);
    fun DrawCubeWiresV(position: Vector3, size: Vector3, color: Color);
    fun DrawSphere(centerPos: Vector3, radius: i32, color: Color);
    fun DrawSphereEx(centerPos: Vector3, radius: i32, rings: i32, slices: i32, color: Color);
    fun DrawSphereWires(centerPos: Vector3, radius: i32, rings: i32, slices: i32, color: Color);
    fun DrawCylinder(position: Vector3, radiusTop: i32, radiusBottom: i32, height: i32, slices: i32, color: Color);
    fun DrawCylinderEx(startPos: Vector3, endPos: Vector3, startRadius: i32, endRadius: i32, sides: i32, color: Color);
    fun DrawCylinderWires(position: Vector3, radiusTop: i32, radiusBottom: i32, height: i32, slices: i32, color: Color);
    fun DrawCylinderWiresEx(startPos: Vector3, endPos: Vector3, startRadius: i32, endRadius: i32, sides: i32, color: Color);
    fun DrawCapsule(startPos: Vector3, endPos: Vector3, radius: i32, slices: i32, rings: i32, color: Color);
    fun DrawCapsuleWires(startPos: Vector3, endPos: Vector3, radius: i32, slices: i32, rings: i32, color: Color);
    fun DrawPlane(centerPos: Vector3, size: Vector2, color: Color);
    fun DrawRay(ray: Ray, color: Color);
    fun DrawGrid(slices: i32, spacing: i32);
    fun LoadModel(fileName: ptr<i8>) -> Model;
    fun LoadModelFromMesh(mesh: Mesh) -> Model;
    fun IsModelValid(model: Model) -> bool;
    fun UnloadModel(model: Model);
    fun GetModelBoundingBox(model: Model) -> BoundingBox;
    fun DrawModel(model: Model, position: Vector3, scale: i32, tint: Color);
    fun DrawModelEx(model: Model, position: Vector3, rotationAxis: Vector3, rotationAngle: i32, scale: Vector3, tint: Color);
    fun DrawModelWires(model: Model, position: Vector3, scale: i32, tint: Color);
    fun DrawModelWiresEx(model: Model, position: Vector3, rotationAxis: Vector3, rotationAngle: i32, scale: Vector3, tint: Color);
    fun DrawModelPoints(model: Model, position: Vector3, scale: i32, tint: Color);
    fun DrawModelPointsEx(model: Model, position: Vector3, rotationAxis: Vector3, rotationAngle: i32, scale: Vector3, tint: Color);
    fun DrawBoundingBox(box: BoundingBox, color: Color);
    fun DrawBillboard(camera: Camera, texture: Texture2D, position: Vector3, scale: i32, tint: Color);
    fun DrawBillboardRec(camera: Camera, texture: Texture2D, source: Rectangle, position: Vector3, size: Vector2, tint: Color);
    fun DrawBillboardPro(camera: Camera, texture: Texture2D, source: Rectangle, position: Vector3, up: Vector3, size: Vector2, origin: Vector2, rotation: i32, tint: Color);
    fun UploadMesh(mesh: ptr<Mesh>, dynamic: bool);
    fun UpdateMeshBuffer(mesh: Mesh, index: i32, data: ptr<u8>, dataSize: i32, offset: i32);
    fun UnloadMesh(mesh: Mesh);
    fun DrawMesh(mesh: Mesh, material: Material, transform: Matrix);
    fun DrawMeshInstanced(mesh: Mesh, material: Material, transforms: ptr<Matrix>, instances: i32);
    fun GetMeshBoundingBox(mesh: Mesh) -> BoundingBox;
    fun GenMeshTangents(mesh: ptr<Mesh>);
    fun ExportMesh(mesh: Mesh, fileName: ptr<i8>) -> bool;
    fun ExportMeshAsCode(mesh: Mesh, fileName: ptr<i8>) -> bool;
    fun GenMeshPoly(sides: i32, radius: i32) -> Mesh;
    fun GenMeshPlane(width: i32, length: i32, resX: i32, resZ: i32) -> Mesh;
    fun GenMeshCube(width: i32, height: i32, length: i32) -> Mesh;
    fun GenMeshSphere(radius: i32, rings: i32, slices: i32) -> Mesh;
    fun GenMeshHemiSphere(radius: i32, rings: i32, slices: i32) -> Mesh;
    fun GenMeshCylinder(radius: i32, height: i32, slices: i32) -> Mesh;
    fun GenMeshCone(radius: i32, height: i32, slices: i32) -> Mesh;
    fun GenMeshTorus(radius: i32, size: i32, radSeg: i32, sides: i32) -> Mesh;
    fun GenMeshKnot(radius: i32, size: i32, radSeg: i32, sides: i32) -> Mesh;
    fun GenMeshHeightmap(heightmap: Image, size: Vector3) -> Mesh;
    fun GenMeshCubicmap(cubicmap: Image, cubeSize: Vector3) -> Mesh;
    fun LoadMaterials(fileName: ptr<i8>, materialCount: ptr<i32>) -> ptr<Material>;
    fun LoadMaterialDefault() -> Material;
    fun IsMaterialValid(material: Material) -> bool;
    fun UnloadMaterial(material: Material);
    fun SetMaterialTexture(material: ptr<Material>, mapType: i32, texture: Texture2D);
    fun SetModelMeshMaterial(model: ptr<Model>, meshId: i32, materialId: i32);
    fun LoadModelAnimations(fileName: ptr<i8>, animCount: ptr<i32>) -> ptr<ModelAnimation>;
    fun UpdateModelAnimation(model: Model, anim: ModelAnimation, frame: i32);
    fun UpdateModelAnimationBones(model: Model, anim: ModelAnimation, frame: i32);
    fun UnloadModelAnimation(anim: ModelAnimation);
    fun UnloadModelAnimations(animations: ptr<ModelAnimation>, animCount: i32);
    fun IsModelAnimationValid(model: Model, anim: ModelAnimation) -> bool;
    fun CheckCollisionSpheres(center1: Vector3, radius1: i32, center2: Vector3, radius2: i32) -> bool;
    fun CheckCollisionBoxes(box1: BoundingBox, box2: BoundingBox) -> bool;
    fun CheckCollisionBoxSphere(box: BoundingBox, center: Vector3, radius: i32) -> bool;
    fun GetRayCollisionSphere(ray: Ray, center: Vector3, radius: i32) -> RayCollision;
    fun GetRayCollisionBox(ray: Ray, box: BoundingBox) -> RayCollision;
    fun GetRayCollisionMesh(ray: Ray, mesh: Mesh, transform: Matrix) -> RayCollision;
    fun GetRayCollisionTriangle(ray: Ray, p1: Vector3, p2: Vector3, p3: Vector3) -> RayCollision;
    fun GetRayCollisionQuad(ray: Ray, p1: Vector3, p2: Vector3, p3: Vector3, p4: Vector3) -> RayCollision;
    fun InitAudioDevice();
    fun CloseAudioDevice();
    fun IsAudioDeviceReady() -> bool;
    fun SetMasterVolume(volume: i32);
    fun GetMasterVolume() -> i32;
    fun LoadWave(fileName: ptr<i8>) -> Wave;
    fun LoadWaveFromMemory(fileType: ptr<i8>, fileData: ptr<u8>, dataSize: i32) -> Wave;
    fun IsWaveValid(wave: Wave) -> bool;
    fun LoadSound(fileName: ptr<i8>) -> Sound;
    fun LoadSoundFromWave(wave: Wave) -> Sound;
    fun LoadSoundAlias(source: Sound) -> Sound;
    fun IsSoundValid(sound: Sound) -> bool;
    fun UpdateSound(sound: Sound, data: ptr<u8>, sampleCount: i32);
    fun UnloadWave(wave: Wave);
    fun UnloadSound(sound: Sound);
    fun UnloadSoundAlias(alias: Sound);
    fun ExportWave(wave: Wave, fileName: ptr<i8>) -> bool;
    fun ExportWaveAsCode(wave: Wave, fileName: ptr<i8>) -> bool;
    fun PlaySound(sound: Sound);
    fun StopSound(sound: Sound);
    fun PauseSound(sound: Sound);
    fun ResumeSound(sound: Sound);
    fun IsSoundPlaying(sound: Sound) -> bool;
    fun SetSoundVolume(sound: Sound, volume: i32);
    fun SetSoundPitch(sound: Sound, pitch: i32);
    fun SetSoundPan(sound: Sound, pan: i32);
    fun WaveCopy(wave: Wave) -> Wave;
    fun WaveCrop(wave: ptr<Wave>, initFrame: i32, finalFrame: i32);
    fun WaveFormat(wave: ptr<Wave>, sampleRate: i32, sampleSize: i32, channels: i32);
    fun LoadWaveSamples(wave: Wave) -> ptr<i32>;
    fun UnloadWaveSamples(samples: ptr<i32>);
    fun LoadMusicStream(fileName: ptr<i8>) -> Music;
    fun LoadMusicStreamFromMemory(fileType: ptr<i8>, data: ptr<u8>, dataSize: i32) -> Music;
    fun IsMusicValid(music: Music) -> bool;
    fun UnloadMusicStream(music: Music);
    fun PlayMusicStream(music: Music);
    fun IsMusicStreamPlaying(music: Music) -> bool;
    fun UpdateMusicStream(music: Music);
    fun StopMusicStream(music: Music);
    fun PauseMusicStream(music: Music);
    fun ResumeMusicStream(music: Music);
    fun SeekMusicStream(music: Music, position: i32);
    fun SetMusicVolume(music: Music, volume: i32);
    fun SetMusicPitch(music: Music, pitch: i32);
    fun SetMusicPan(music: Music, pan: i32);
    fun GetMusicTimeLength(music: Music) -> i32;
    fun GetMusicTimePlayed(music: Music) -> i32;
    fun LoadAudioStream(sampleRate: u32, sampleSize: u32, channels: u32) -> AudioStream;
    fun IsAudioStreamValid(stream: AudioStream) -> bool;
    fun UnloadAudioStream(stream: AudioStream);
    fun UpdateAudioStream(stream: AudioStream, data: ptr<u8>, frameCount: i32);
    fun IsAudioStreamProcessed(stream: AudioStream) -> bool;
    fun PlayAudioStream(stream: AudioStream);
    fun PauseAudioStream(stream: AudioStream);
    fun ResumeAudioStream(stream: AudioStream);
    fun IsAudioStreamPlaying(stream: AudioStream) -> bool;
    fun StopAudioStream(stream: AudioStream);
    fun SetAudioStreamVolume(stream: AudioStream, volume: i32);
    fun SetAudioStreamPitch(stream: AudioStream, pitch: i32);
    fun SetAudioStreamPan(stream: AudioStream, pan: i32);
    fun SetAudioStreamBufferSizeDefault(size: i32);
    fun SetAudioStreamCallback(stream: AudioStream, callback: AudioCallback);
    fun AttachAudioStreamProcessor(stream: AudioStream, processor: AudioCallback);
    fun DetachAudioStreamProcessor(stream: AudioStream, processor: AudioCallback);
    fun AttachAudioMixedProcessor(processor: AudioCallback);
    fun DetachAudioMixedProcessor(processor: AudioCallback);
}